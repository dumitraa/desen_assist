# -*- coding: utf-8 -*-
"""
/***************************************************************************
 DesenAssist
                                 A QGIS plugin
 Helps in assisting for Enel
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2024-11-29
        git sha              : $Format:%H$
        copyright            : (C) 2024 by Ionela
        email                : ioneladumitra@yahoo.ro
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

from PyQt5.QtCore import QVariant # type: ignore
from qgis.PyQt.QtCore import QCoreApplication, QSettings, QTranslator # type: ignore
from qgis.PyQt.QtGui import QIcon # type: ignore
from qgis.PyQt.QtWidgets import QAction, QMessageBox # type: ignore
from qgis.core import ( # type: ignore
    QgsFeature,
    QgsField,
    QgsFields,
    QgsMessageLog,
    QgsProcessingContext,
    QgsProject,
    QgsVectorLayer,
    QgsProcessingFeedback,
    Qgis
    )
from pathlib import Path
import processing # type: ignore
import re
from collections import defaultdict

import os
import os.path

from .resources import *

from .func.helper_functions import HelperBase, SHPProcessor
from . import config

class DesenAssist:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        self.context = QgsProcessingContext()
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        self.helper = HelperBase()
        self.processor = None
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'DesenAssist_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&DesenAssist')
        
        self.layers = self.helper.get_layers()

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None


    @staticmethod
    def plugin_path(*args) -> Path:
        """ Return the path to the plugin root folder or file. """
        path = Path(__file__).resolve().parent
        for item in args:
            path = path.joinpath(item)
        return path


    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('DesenAssist', message)


    def add_action(
        self,
        name,
        text,
        callback=None,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None,
        icon_path=None,
        shortcut=None,):
        
        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.setEnabled(enabled_flag)

        if callback is not None:
            action.triggered.connect(callback)
            action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)
            
        if shortcut is not None:
            action.setShortcut(shortcut)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            self.toolbar.addAction(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action


    def initGui(self):
        self.toolbar = self.iface.addToolBar('DesenAssist')
        self.toolbar.setObjectName('DesenAssist')
        self.toolbar.setMovable(True)
        
        # Adding actions with default enabled flag set to False except "Fisier Destinatie"
        self.actions_to_enable = [
            self.add_action(
                "Verificare numerotare stâlpi",
                text=self.tr(u'Verificare numerotare stâlpi'),
                callback=self.verify_pole_numbering,
                parent=self.iface.mainWindow(),
                icon_path= str(self.plugin_path('icons/1.png')),
                enabled_flag=True
            ),
            self.add_action(
                "Verificare denumire străzi - STALP_JT",
                text=self.tr(u'Verificare denumire străzi - STALP_JT'),
                callback=self.verify_street_names_poles,
                parent=self.iface.mainWindow(),
                icon_path= str(self.plugin_path('icons/2.png')),
                enabled_flag=True
            ),
            self.add_action(
                "Completare denumiri străzi - STALP_JT",
                text=self.tr(u'Completare denumiri străzi - STALP_JT'),
                callback=self.complete_street_names_poles,
                parent=self.iface.mainWindow(),
                icon_path= str(self.plugin_path('icons/3.png')),
                enabled_flag=True
            ),
            self.add_action(
                "Verificare denumire străzi branșamente",
                text=self.tr(u'Verificare denumire străzi branșamente'),
                callback=self.validate_street_names,
                parent=self.iface.mainWindow(),
                icon_path= str(self.plugin_path('icons/4.png')),
                enabled_flag=True
            ),
            self.add_action(
                "Corespondență LINIA_JT la Bransament și Tronson",
                text=self.tr(u'Corespondență LINIA_JT'),
                callback=self.verify_linia_jt_matches,
                parent=self.iface.mainWindow(),
                icon_path= str(self.plugin_path('icons/5.png')),
                enabled_flag=True
            ),
            self.add_action(
                "Corelare câmpuri branșamente",
                text=self.tr(u'Corelare câmpuri branșamente'),
                callback=self.correlate_branch_fields,
                parent=self.iface.mainWindow(),
                icon_path= str(self.plugin_path('icons/6.png')),
                enabled_flag=True
            ),
            self.add_action(
                "Verificare coloană PROP",
                text=self.tr(u'Verificare coloană PROP'),
                callback=self.verify_prop_column,
                parent=self.iface.mainWindow(),
                icon_path= str(self.plugin_path('icons/7.png')),
                enabled_flag=True
            ),
            self.add_action(
                "Verificare coloane obligatorii",
                text=self.tr(u'Verificare coloane obligatorii'),
                callback=self.verify_mandatory_columns,
                parent=self.iface.mainWindow(),
                icon_path= str(self.plugin_path('icons/8.png')),
                enabled_flag=True
            ),
            self.add_action(
                "Verificare circuit greșit",
                text=self.tr(u'Verificare circuit greșit'),
                callback=self.verify_circuit,
                parent=self.iface.mainWindow(),
                icon_path= str(self.plugin_path('icons/9.png')),
                enabled_flag=True
            ),
            self.add_action(
                "Verificare greseli (coloane alfanumerice, colerari gresite) - STALP_JT",
                text=self.tr(u'Verificare greseli'),
                callback=self.verify_mistakes,
                parent=self.iface.mainWindow(),
                icon_path= str(self.plugin_path('icons/10.png')),
            )
        ]
        
        # will be set False in run()
        self.first_start = True


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(self.tr(u'&Enel Assist'), action)
            self.toolbar.removeAction(action)
        del self.toolbar
        
    def get_layer_path(self, layer_name):
        """
        Get the full data source path of a layer by its name.

        Parameters:
            layer_name (str): The name of the layer in the QGIS project.

        Returns:
            str: The full data source path of the layer, including `|layername=`.
                Returns None if the layer is not found.
        """
        # Search for the layer by name in the current project
        layers = QgsProject.instance().mapLayersByName(layer_name)
        if not layers:
            return None
        
        # Get the first matching layer
        layer = layers[0]
        # Extract the data source path
        data_source = layer.dataProvider().dataSourceUri()
        
        # Append layername (important for GPKG files with multiple layers)
        if layer.storageType() == "GeoPackage" and "|layername=" not in data_source:
            data_source += f"|layername={layer.name()}"
        
        return data_source

    def clean_denum(self, denum):
        denum = str(denum)
        if denum:
            # Extract numeric and alphabetic parts
            match = re.match(r'(\d+)([A-Za-z]*)', denum)
            if match:
                numeric_part = int(match.group(1))  # Numeric part
                alpha_part = match.group(2).upper()  # Alphabetic part (uppercased)
                return (numeric_part, alpha_part)
        return (float('inf'), '')  # Non-matching cases go to the end

# A.	Verificare numerotare stalpi
    def verify_pole_numbering(self):
        self.verify_pole_numbering_br()
        self.verify_pole_numbering_jt()
        QMessageBox.information(None, "Verificare numerotare stâlpi", "Verificare finalizată cu succes! Stâlpii au fost sortați și numerotați corect.")

    def verify_pole_numbering_br(self):
        """
        Verifies and sorts features numerically by the alphanumeric value of DENUM.
        Also, ensures DENUM values are uppercased and modifies the original layer for "JT" features.
        """
        original_layer = QgsProject.instance().mapLayersByName("STALP_JT")[0]

        # Uppercase the DENUM field in the original layer and save changes
        original_layer.startEditing()
        for feature in original_layer.getFeatures():
            denum = feature["DENUM"]
            if denum:
                feature["DENUM"] = denum.upper()
                original_layer.updateFeature(feature)
        original_layer.commitChanges()

        jt_features = [f for f in original_layer.getFeatures() if re.search(r'[A-Za-z]', str(f["DENUM"]))]
        jt_features_sorted = sorted(jt_features, key=lambda f: self.clean_denum(f["DENUM"]))

        # Create a new scratch layer for BR features
        scratch_layer = QgsVectorLayer(
            "Point?crs=" + original_layer.crs().toWkt(),
            "Verificare_auxiliari",
            "memory"
        )
        scratch_layer_data = scratch_layer.dataProvider()

        # Add only the necessary fields
        fields = QgsFields()
        fields.append(QgsField("fid", QVariant.Int))  # Original feature ID
        fields.append(QgsField("TIP_CIR", QVariant.String))
        fields.append(QgsField("DENUM", QVariant.String))
        scratch_layer_data.addAttributes(fields)
        scratch_layer.updateFields()

        # Populate the new layer with sorted features and compute new fields
        for idx, feature in enumerate(jt_features_sorted):  # Enumerate in the sorted DENUM order
            new_feature = QgsFeature()
            new_feature.setGeometry(feature.geometry())
            new_feature.setFields(scratch_layer.fields())

            # Add new fields
            new_feature["fid"] = feature.id()
            new_feature["TIP_CIR"] = feature["TIP_CIR"]
            new_feature["DENUM"] = feature["DENUM"]

            # Add feature to the scratch layer
            scratch_layer_data.addFeature(new_feature)

        # Add the scratch layer to the project
        QgsProject.instance().addMapLayer(scratch_layer)


    def verify_pole_numbering_jt(self):
        """
        Normalizes DENUM fields in the STALP_JT layer (features where TIP_CIR includes 'JT') so that:
        - Consecutive duplicates with no suffix (e.g. 11, 11, 12) become 11, 12, 13
        - If there's a suffix involved (e.g. 11, 11A, 11A), everything shares the same base and suffixes start at A:
            e.g. => 11, 11A, 11B
        - Ensures base numbers are sequential with no gaps (e.g. 41, 43 becomes 41, 42)
        """

        original_layer = QgsProject.instance().mapLayersByName("STALP_JT")[0]
        jt_features = [f for f in original_layer.getFeatures() if "JT" in f["TIP_CIR"]]

        denum_map = {}
        for feat in jt_features:
            feature_id = feat.id()
            base_suffix = self.clean_denum(feat["DENUM"])  # returns (base_int, suffix_str)
            denum_map[feature_id] = base_suffix

        sorted_items = sorted(denum_map.items(), key=lambda x: (x[1][0], x[1][1]))

        assigned_bases = set()
        base_suffix_count = defaultdict(int)
        final_assignments = {}
        
        all_bases = sorted(set(base for _, (base, _) in sorted_items))
        min_base = all_bases[0] if all_bases else 1
        
        def next_unused_base(candidate, used_bases):
            """Finds the next available base number without gaps."""
            while candidate in used_bases:
                candidate += 1
            return candidate

        sequential_bases = {old: new for old, new in zip(all_bases, range(min_base, min_base + len(all_bases)))}
        
        for feat_id, (base, suffix) in sorted_items:
            suffix = suffix.upper()
            new_base = sequential_bases[base]  # Remap base to sequential numbering
            
            if new_base not in assigned_bases:
                final_assignments[feat_id] = (new_base, "")
                assigned_bases.add(new_base)
                base_suffix_count[new_base] = 0
            else:
                if suffix == "":
                    new_base = next_unused_base(new_base, assigned_bases)
                    final_assignments[feat_id] = (new_base, "")
                    assigned_bases.add(new_base)
                    base_suffix_count[new_base] = 0
                else:
                    cur_count = base_suffix_count[new_base]
                    letter = chr(65 + cur_count)  # 65 is 'A'
                    final_assignments[feat_id] = (new_base, letter)
                    base_suffix_count[new_base] = cur_count + 1

        original_layer.startEditing()

        for feat_id, (new_base, new_suffix) in final_assignments.items():
            new_denum = f"{new_base}{new_suffix}"
            try:
                feature = original_layer.getFeature(feat_id)
                feature["DENUM"] = new_denum
                original_layer.updateFeature(feature)
            except Exception as e:
                QgsMessageLog.logMessage(
                    f"Error updating feature {feat_id} -> {new_base}{new_suffix}: {e}",
                    'DesenAssist',
                    Qgis.Critical
                )

        original_layer.commitChanges()





#. B.	Denumirea strazilor pentru stalpi - WORKING BUT NOTE: THEY NEED TO TEST IT TO SEE IF IT WORKS THE WAY THEY WANT
    def complete_street_names_poles(self):
        # Layers involved
        stalp_layer_name = "STALP_JT"
        strazi_layer_name = "strazi"

        # Get the layers
        stalp_layer = QgsProject.instance().mapLayersByName(stalp_layer_name)
        strazi_layer = QgsProject.instance().mapLayersByName(strazi_layer_name)

        if not stalp_layer or not strazi_layer:
            QgsMessageLog.logMessage("One or both layers are not loaded.", 'DesenAssist', Qgis.Critical)
            return

        stalp_layer = stalp_layer[0]
        strazi_layer = strazi_layer[0]

        # Prepare processing feedback
        feedback = QgsProcessingFeedback()

        try:
            # Step 1: Replace diacritics and remove "Strada " prefix
            stalp_layer.updateFields()
            
            for feature in strazi_layer.getFeatures():
                field_value = feature["DENUMIRE_D"]  # Replace "Field" with the actual field name
                cleaned_value = (field_value
                                .replace('ă', 'a').replace('â', 'a').replace('Ă', 'A')
                                .replace('î', 'i').replace('Î', 'I')
                                .replace('ș', 's').replace('Ș', 'S')
                                .replace('ț', 't').replace('Ț', 'T')
                                .replace('Strada ', ''))
                strazi_layer.dataProvider().changeAttributeValues({
                    feature.id(): {strazi_layer.fields().indexOf('DENUMIRE_D'): cleaned_value}
                })

            # Step 2: Buffer of 10m around STALP_JT
            buffer_params = {
                'INPUT': stalp_layer,
                'DISTANCE': 10,
                'SEGMENTS': 5,
                'END_CAP_STYLE': 0,
                'JOIN_STYLE': 0,
                'MITER_LIMIT': 2,
                'DISSOLVE': False,
                'OUTPUT': 'memory:'
            }
            buffer_result = processing.run("native:buffer", buffer_params, feedback=feedback)
            buffer_layer = buffer_result['OUTPUT']

            # Step 3: Dissolve buffer layer
            dissolve_params = {
                'INPUT': buffer_layer,
                'OUTPUT': 'memory:'
            }
            dissolve_result = processing.run("native:dissolve", dissolve_params, feedback=feedback)
            dissolve_layer = dissolve_result['OUTPUT']

            # Step 4: Multipart to single parts
            singleparts_params = {
                'INPUT': dissolve_layer,
                'OUTPUT': 'memory:'
            }
            singleparts_result = processing.run("native:multiparttosingleparts", singleparts_params, feedback=feedback)
            singleparts_layer = singleparts_result['OUTPUT']

            # Step 5: Join Attributes by Location with "Strazi" layer
            join_params_1 = {
                'INPUT': singleparts_layer,
                'JOIN': strazi_layer,
                'PREDICATE': [0],  # Intersects
                'JOIN_FIELDS': ['DENUMIRE_D'],
                'METHOD': 0,  # Create temporary layer
                'DISCARD_NONMATCHING': False,
                'OUTPUT': 'memory:'
            }
            join_result_1 = processing.run("native:joinattributesbylocation", join_params_1, feedback=feedback)
            joined_layer_1 = join_result_1['OUTPUT']

            # Step 6: Delete Duplicate Geometries
            delete_duplicates_params = {
                'INPUT': joined_layer_1,
                'OUTPUT': 'memory:'
            }
            delete_duplicates_result = processing.run("native:deleteduplicategeometries", delete_duplicates_params, feedback=feedback)
            deduplicated_layer = delete_duplicates_result['OUTPUT']

            # Step 7: Join Attributes by Location with original STALP_JT layer
            join_params_2 = {
                'INPUT': stalp_layer,
                'JOIN': deduplicated_layer,
                'PREDICATE': [0],  # Intersects
                'JOIN_FIELDS': ['DENUMIRE_D'],
                'METHOD': 0,  # Create temporary layer
                'DISCARD_NONMATCHING': False,
                'OUTPUT': 'memory:'
            }
            join_result_2 = processing.run("native:joinattributesbylocation", join_params_2, feedback=feedback)
            final_layer = join_result_2['OUTPUT']
            final_layer.setName("STALP_JT_completare_strazi")

            # Step 8: Export the final layer
            QgsProject.instance().addMapLayer(final_layer)


        except Exception as e:
            QgsMessageLog.logMessage(f"An error occurred: {e}", 'DesenAssist', Qgis.Critical)



# C.	Coloana “linie jt” sa fie la fel la bransament si la tronson - WORKING

    def verify_linia_jt_matches(self):
        '''
        Creates a scratch layer to compare BRANS_FIRI_GRPM_JT with TRONSON_JT.
        Verifies if LINIA_JT matches LINITA_JT, ensuring the features make sense spatially.
        '''

        # Load layers
        brans_layer = QgsProject.instance().mapLayersByName('BRANS_FIRI_GRPM_JT')[0]
        tronson_layer = QgsProject.instance().mapLayersByName('TRONSON_JT')[0]

        if not brans_layer or not tronson_layer:
            QgsMessageLog.logMessage("One or both layers are not loaded.", 'DesenAssist', Qgis.Critical)
            return

        # Create a scratch layer
        scratch_layer = QgsVectorLayer("LineString?crs=EPSG:3844", "LINIA_JT_verificare", "memory")

        # Combine fields and add to the scratch layer
        fields = brans_layer.fields()
        fields.append(QgsField('MATCH_STATUS', QVariant.String))  # Add MATCH_STATUS field
        scratch_layer.dataProvider().addAttributes(fields)
        scratch_layer.updateFields()
        QgsProject.instance().addMapLayer(scratch_layer)

        # Compare features
        for brans_feature in brans_layer.getFeatures():
            linia_jt = brans_feature['LINIA_JT']
            if not linia_jt:
                continue

            # Find matching tronson features by attribute and spatial relationship
            match_found = False
            for tronson_feature in tronson_layer.getFeatures():
                if tronson_feature['LINIA_JT'] == linia_jt:
                    if brans_feature.geometry().intersects(tronson_feature.geometry()):
                        match_found = True
                        break

            # Add result to scratch layer
            new_feature = QgsFeature()
            new_feature.setGeometry(brans_feature.geometry())
            new_feature.setAttributes(brans_feature.attributes() + ['Da' if match_found else 'Nu'])
            scratch_layer.dataProvider().addFeature(new_feature)

        # Commit scratch layer
        scratch_layer.commitChanges()
        

# D.	Corelare campuri pentru bransamente – trifazat, monofazat - WORKING

    def correlate_branch_fields(self):
        '''
        Verifies if TIP_BR and TIP_FIRI_BR fields in BRANS_FIRI_GRPM_JT are correctly matched.
        '''
        # Define the mapping rules
        mapping = {
            "monofazat": ["FB1", "FM1", "BMPM", "FDCP", "FDCS"],
            "trifazat": ["FB3", "FM3", "BMPT", "FDCP", "FDCS"],
        }

        # Get the input layer
        input_layer = QgsProject.instance().mapLayersByName("BRANS_FIRI_GRPM_JT")
        if not input_layer:
            QgsMessageLog.logMessage("Layer 'BRANS_FIRI_GRPM_JT' not found.", 'DesenAssist', Qgis.Critical)
            return

        input_layer = input_layer[0]

        # Create a new scratch layer
        scratch_layer = QgsVectorLayer(
            "LineString?crs=EPSG:3844",
            "TIP_BR_verificare",
            "memory"
        )

        # Define fields for the scratch layer
        fields = input_layer.fields()
        fields.append(QgsField("MATCH_STATUS", QVariant.String))
        scratch_layer.dataProvider().addAttributes(fields)
        scratch_layer.updateFields()
        QgsProject.instance().addMapLayer(scratch_layer)

        # Iterate through features in the input layer
        for feature in input_layer.getFeatures():
            tip_br = feature["TIP_BR"]
            tip_firi_br = feature["TIP_FIRI_BR"]
            
            # Check if TIP_BR exists in mapping
            if tip_br in mapping:
                valid_values = mapping[tip_br]
                match_status = "Da" if tip_firi_br in valid_values else "Nu"
            else:
                match_status = "Invalid TIP_BR"

            # Create a new feature for the scratch layer
            new_feature = QgsFeature(fields)
            new_feature.setGeometry(feature.geometry())
            new_feature.setAttributes(feature.attributes() + [match_status])

            # Add the feature to the scratch layer
            scratch_layer.dataProvider().addFeature(new_feature)

        # Add the scratch layer to the project
        QgsProject.instance().addMapLayer(scratch_layer)
        

# E.	Verificare denumiri strazi bransamente - WORKING
    def validate_street_names(self):
        # Hardcoded layer names
        brans_layer_name = "BRANS_FIRI_GRPM_JT"
        stalp_layer_name = "STALP_JT"

        # Get the layers
        brans_layer = QgsProject.instance().mapLayersByName(brans_layer_name)
        stalp_layer = QgsProject.instance().mapLayersByName(stalp_layer_name)

        if not brans_layer or not stalp_layer:
            QgsMessageLog.logMessage("One or both layers are not loaded.", 'DesenAssist', Qgis.Critical)
            return

        brans_layer = brans_layer[0]
        stalp_layer = stalp_layer[0]

        # Prepare processing feedback
        feedback = QgsProcessingFeedback()
        context = QgsProcessingContext()

        # Run the spatial join
        params = {
            'INPUT': brans_layer,
            'JOIN': stalp_layer,
            'PREDICATE': [0],  # Intersects
            'JOIN_FIELDS': ['STR'],  # Join the STR field from the stalp layer
            'METHOD': 0,  # Create temporary layer
            'DISCARD_NONMATCHING': False,
            'OUTPUT': 'memory:'  # Output to memory
        }

        try:
            join_output = processing.run("native:joinattributesbylocation", params, context=context)
            joined_layer = join_output['OUTPUT']
            joined_layer.setName("Validare_denumiri_strazi_bransamente")

            # Add the MATCH_STATUS column
            joined_layer.dataProvider().addAttributes([QgsField("MATCH_STATUS", QVariant.String)])
            joined_layer.updateFields()

            # Check STR values and populate MATCH_STATUS
            for feature in joined_layer.getFeatures():
                brans_str = feature['STR']
                stalp_str = feature['STR_2']  # STR from stalp layer after the join
                match_status = "Da" if brans_str == stalp_str else "Nu"
                feature['MATCH_STATUS'] = match_status
                joined_layer.dataProvider().changeAttributeValues({feature.id(): {joined_layer.fields().indexOf('MATCH_STATUS'): match_status}})

            # Add the output to the project
            QgsProject.instance().addMapLayer(joined_layer)
        except Exception as e:
            QgsMessageLog.logMessage(f"An error occurred: {e}", 'DesenAssist', Qgis.Critical)

        
# F.	Completare automata a coloanei “PROP” de la STALP_JT - WORKING

    def verify_prop_column(self):
        '''
        Verifies the PROP column in STALP_JT based on the DESC_CTG_MT_JT and PROP columns.
        '''
        orig_layer = QgsProject.instance().mapLayersByName('STALP_JT')[0]
        stalp_layer = QgsVectorLayer("Point?crs=EPSG:3844", "STALP_JT_verificare_prop", "memory")
        stalp_layer_data = stalp_layer.dataProvider()
        stalp_layer.startEditing()
        stalp_layer_data.addAttributes(orig_layer.fields())
        stalp_layer.updateFields()
        for feature in orig_layer.getFeatures():
            stalp_layer.addFeature(feature)
        stalp_layer.commitChanges()
        QgsProject.instance().addMapLayer(stalp_layer)

        if not stalp_layer:
            QgsMessageLog.logMessage("Layer 'STALP_JT' not found.", 'DesenAssist', Qgis.Critical)
        else:
            if 'MATCH_STATUS' not in [field.name() for field in stalp_layer.fields()]:
                stalp_layer.dataProvider().addAttributes([QgsField('MATCH_STATUS', QVariant.String)])
                stalp_layer.updateFields()

            terti_codes = [
                'St. lemn tip SU', 'St. lemn tip SG', 'St. metalic rotund',
                'St. octogonal zincat sustinere', 'St. octogonal zincat intindere'
            ]
            electrica_codes = [
                'S 8 - U', 'S 9 - U', 'S 10 - U', 'S 10 - M', 'S 12 - M', 'S 10 - G',
                'S 11 - G', 'S 12 - G', 'S 13 - G', 'S 14 - G', 'SE 1A', 'SE 2', 'SE 3',
                'SE 4', 'SE 5', 'SE 6', 'SE 7', 'SE 8', 'SE 9', 'SE 10', 'SE 11',
                'SC 10001', 'SC 10002', 'SC 10005', 'SC 15004', 'SC 15006', 'SC 15007',
                'SC 15014-10.5', 'SC 15014', 'SI 9', 'SV 10001', 'SV 10002'
            ]
            
            stalp_layer.startEditing()

            for feature in stalp_layer.getFeatures():
                desc_value = feature['DESC_CTG_MT_JT']
                prop_value = feature['PROP']
                if desc_value in terti_codes and prop_value != 'TERTI':
                    feature['MATCH_STATUS'] = 'Nu'
                elif desc_value in electrica_codes and prop_value != 'ELECTRICA':
                    feature['MATCH_STATUS'] = 'Nu'
                elif desc_value in electrica_codes and prop_value == 'ELECTRICA':
                    feature['MATCH_STATUS'] = 'Da'
                elif desc_value in terti_codes and prop_value == 'TERTI':
                    feature['MATCH_STATUS'] = 'Da'
                stalp_layer.updateFeature(feature)
            if not stalp_layer.commitChanges():
                QgsMessageLog.logMessage("Error committing changes.", 'DesenAssist', Qgis.Critical)
        QgsProject.instance().write()
    
    
 # G.	Verificarea denumirilor strazilor din layerul STALP_JT (layerul din renns va avea denumirea “nr_postale”) - WORKING
    
    def verify_street_names_poles(self):
        def normalize_text(text):
            replacements = {
                'ă': 'a', 'â': 'a', 'î': 'i', 'ș': 's', 'ş': 's', 'ț': 't', 'ţ': 't',
                'Ă': 'A', 'Â': 'A', 'Î': 'I', 'Ș': 'S', 'Ş': 'S', 'Ț': 'T', 'Ţ': 'T'
            }
            for diacritic, replacement in replacements.items():
                text = text.replace(diacritic, replacement)
            return text.upper()

        orig_layer = QgsProject.instance().mapLayersByName('STALP_JT')[0]
        nr_postale_layer = QgsProject.instance().mapLayersByName('nr_postale')[0]

        stalp_layer = QgsVectorLayer("Point?crs=EPSG:3844", "STALP_JT_verificare_denum", "memory")
        stalp_layer_data = stalp_layer.dataProvider()
        stalp_layer.startEditing()
        stalp_layer_data.addAttributes(orig_layer.fields())
        stalp_layer.updateFields()
        for feature in orig_layer.getFeatures():
            stalp_layer.addFeature(feature)
        stalp_layer.commitChanges()
        QgsProject.instance().addMapLayer(stalp_layer)

        if stalp_layer and nr_postale_layer:
            if 'MATCH_STATUS' not in [field.name() for field in stalp_layer.fields()]:
                stalp_layer.dataProvider().addAttributes([QgsField('MATCH_STATUS', QVariant.String)])
                stalp_layer.updateFields()

            denumire_d_values = set()
            for feature in nr_postale_layer.getFeatures():
                denumire_d = feature['DENUMIRE_D']
                if denumire_d:
                    denumire_d_values.add(normalize_text(denumire_d))
                
            stalp_layer.startEditing()

            for feature in stalp_layer.getFeatures():
                str_value = feature['STR']
                if str_value:
                    normalized_str = normalize_text(str_value)
                    if normalized_str not in denumire_d_values:
                        feature['MATCH_STATUS'] = 'Nu'
                    else:
                        feature['MATCH_STATUS'] = 'Da'
                    stalp_layer.updateFeature(feature)

        QgsProject.instance().write()
    
#. H.	Verificarea coloanelor unde campurile sunt obligatorii - WORKING
    def verify_mandatory_columns(self):
        layers_to_check = {
            "STALP_JT": [
                "DENUM", "NR_INS_STP", "PROP", "JUD", "PRIM", "LOC", "TIP_STR", "STR", 
                "TIP_CIR", "DESC_CTG_MT_JT", "NR_CIR", "UZURA_STP", "TIP_FUND", 
                "ADAOS", "TIP_LEG_JT", "fid"],
            "BRANS_FIRI_GRPM_JT": [
                "fid", "TIP_BR", "TIP_COND", "JUD", "PRIM", "LOC", "TIP_STR", "STR", 
                "NR_IMOB", "TIP_FIRI_BR", "LINIA_JT"],
            "TRONSON_JT": [
                "TIP_TR", "TIP_COND", "fid", "LINIA_JT"],
            "FB pe C LES": [
                "fid", "DENUM", "TIP_BR", "TIP_COND", "JUD", "PRIM", "LOC", "TIP_STR", 
                "STR", "NR_IMOB", "SURSA_COORD", "DATA_COORD", "TIP_FIRI_BR", "LINIA_JT"],
            "LINIE_JT": [
                "ID_BDI", "DENUM"]
        }

        layer_types = {
            "STALP_JT": "Point",
            "FB pe C LES": "Point",
            "TRONSON_JT": "LineString",
            "BRANS_FIRI_GRPM_JT": "LineString",
            "LINIE_JT": "None"
        }

        created_layers = {}

        for layer_name, columns in layers_to_check.items():
            layers = QgsProject.instance().mapLayersByName(layer_name.strip())
            if not layers:
                continue

            layer = layers[0]
            geom_type = layer_types[layer_name]

            scratch_layer = None
            for feature in layer.getFeatures():
                if layer_name == "STALP_JT":
                    incomplete_columns = set()
                    nr_cir_fo_val = feature['NR_CIR_FO']
                    prop_fo_val = feature['PROP_FO']
                    
                    if nr_cir_fo_val not in config.NULL_VALUES and prop_fo_val in config.NULL_VALUES:
                        QgsMessageLog.logMessage(f"Feature {feature.id()} has NR_CIR_FO but PROP_FO is empty.", 'DesenAssist', Qgis.Warning)
                        incomplete_columns.add('PROP_FO (NR_CIR_FO e completat)')
                    else:
                        QgsMessageLog.logMessage(f"Feature {feature.id()} has NR_CIR_FO and PROP_FO.", 'DesenAssist', Qgis.Info)
                                
                    for column in columns:
                        if column not in [field.name() for field in layer.fields()]:
                            continue
                        value = feature[column]
                        if value in config.NULL_VALUES:
                            incomplete_columns.add(column)
                        
                if incomplete_columns:
                    if not scratch_layer:
                        scratch_layer = self.create_scratch_layer(f"{layer_name}_coloane_necompletate", geom_type)
                        created_layers[layer_name] = scratch_layer

                    new_feature = QgsFeature(scratch_layer.fields())
                    new_feature.setAttributes([
                        layer_name,                         
                        ", ".join(incomplete_columns),     
                        feature.id()                            
                    ])
                    if geom_type != "None":
                        geometry = feature.geometry()
                        if geometry and geometry.isGeosValid():
                            new_feature.setGeometry(geometry)
                            
                    scratch_layer.dataProvider().addFeature(new_feature)

        for name, layer in created_layers.items():
            QgsProject.instance().addMapLayer(layer)

# I.	Verificare circuit gresit - WORKING
    def verify_circuit(self):
        # Hardcoded layer name
        tronson_layer_name = "TRONSON_JT"

        # Get the layer
        tronson_layer = QgsProject.instance().mapLayersByName(tronson_layer_name)

        if not tronson_layer:
            return

        tronson_layer = tronson_layer[0]

        # Step 1: Dissolve by LINIA_JT
        dissolve_params = {
            'INPUT': tronson_layer,
            'FIELD': ['LINIA_JT'],
            'OUTPUT': 'memory:',
        }
        dissolved_layer = processing.run("native:dissolve", dissolve_params)['OUTPUT']

        # Step 2: Buffer with 0.001
        buffer_params = {
            'INPUT': dissolved_layer,
            'DISTANCE': 0.001,
            'SEGMENTS': 5,
            'END_CAP_STYLE': 0,
            'JOIN_STYLE': 0,
            'MITER_LIMIT': 2,
            'DISSOLVE': False,
            'OUTPUT': 'memory:',
        }
        buffered_layer = processing.run("native:buffer", buffer_params)['OUTPUT']

        # Step 3: Multipart to Singlepart
        singlepart_params = {
            'INPUT': buffered_layer,
            'OUTPUT': 'memory:',
        }
        singlepart_layer = processing.run("native:multiparttosingleparts", singlepart_params)['OUTPUT']

        # Rename the output layer before adding it to the project
        singlepart_layer.setName("Verificare_circuite")

        # Add the resulting layer to the project
        QgsProject.instance().addMapLayer(singlepart_layer)
        
    def verify_mistakes(self):
        self.verify_num_columns()
        self.verify_true_false_columns()
        
    # J.	Verificare numar coloane
    def verify_num_columns(self):
        layers_to_check = {
            "STALP_JT": [
                "UZURA_STP", "NR_CIR_FO", "NR_CIR_LTC", "NR_CIR_CATV", "NR_CONS_C2S", "NR_CONS_C4S", "NR_CONS_C2T", "NR_CONS_C4T", "NR_CONS_C2BR", "NR_CONS_C4BR"]
        }

        layer_types = {
            "STALP_JT": "Point",
        }

        created_layers = {}

        for layer_name, columns in layers_to_check.items():
            layers = QgsProject.instance().mapLayersByName(layer_name.strip())
            if not layers:
                continue

            layer = layers[0]
            geom_type = layer_types[layer_name]

            scratch_layer = None
            for feature in layer.getFeatures():
                incorrect_column = set()
                for column in columns:
                    if column not in [field.name() for field in layer.fields()]:
                        continue
                    value = feature[column]
                    if value not in config.NULL_VALUES:
                        try:
                            value = int(str(value))
                        except ValueError:
                            incorrect_column.add(column)

                if incorrect_column:
                    if not scratch_layer:
                        scratch_layer = self.create_scratch_layer(f"{layer_name}_coloane_gresite_nr", geom_type)
                        created_layers[layer_name] = scratch_layer

                    new_feature = QgsFeature(scratch_layer.fields())
                    new_feature.setAttributes([
                        layer_name,                         
                        ", ".join(incorrect_column),     
                        feature.id()                            
                    ])
                    if geom_type != "None":
                        geometry = feature.geometry()
                        if geometry and geometry.isGeosValid():
                            new_feature.setGeometry(geometry)
                            
                    scratch_layer.dataProvider().addFeature(new_feature)
        for _, layer in created_layers.items():
            QgsProject.instance().addMapLayer(layer)
            
    def verify_true_false_columns(self):
        columns_to_check = {
            "NR_CIR_FO": "FIB_OPT",
            "NR_CIR_LTC": "LTC",
            "NR_CIR_CATV": "CATV",
        }

        created_layers = {}

        layer = QgsProject.instance().mapLayersByName("STALP_JT")[0]

        scratch_layer = None
        for feature in layer.getFeatures():
            incorrect_columns = set()
            for key_field, bool_field in columns_to_check.items():
                if key_field not in [field.name() for field in layer.fields()] or bool_field not in [field.name() for field in layer.fields()]:
                    continue  # Skip if the key field or bool field is not present

                key_value = feature[key_field]  # Get the value of the key field
                bool_value = feature[bool_field]  # Get the value of the bool field

                # Check if key_value is completed (not null or empty)
                is_completed = key_value not in config.NULL_VALUES

                # Ensure the boolean value matches the expected logic
                if is_completed and bool_value.lower() not in [1, 'true', 'yes', 'da']:
                    incorrect_columns.add(bool_field)  # Expected "true" but got something else
                elif not is_completed and bool_value.lower() not in [0, 'false', 'no', 'nu']:
                    incorrect_columns.add(bool_field)  # Expected "false" but got something else

            if incorrect_columns:
                if not scratch_layer:
                    scratch_layer = self.create_scratch_layer(f"STALP_JT_coloane_gresite_bool", "Point")
                    created_layers["STALP_JT"] = scratch_layer

                new_feature = QgsFeature(scratch_layer.fields())
                new_feature.setAttributes([
                    "STALP_JT",                         
                    ", ".join(incorrect_columns),     
                    feature.id()                            
                ])
                geometry = feature.geometry()
                if geometry and geometry.isGeosValid():
                    new_feature.setGeometry(geometry)
                    
                scratch_layer.dataProvider().addFeature(new_feature)
        for _, layer in created_layers.items():
            QgsProject.instance().addMapLayer(layer)
        
# Process Layers
    def process_layers(self, layers):
        if not self.processor:
            try:
                self.processor = SHPProcessor(layers)
            except Exception as e:
                return
        
        try:
            current_layers = self.helper.get_layers()
        except Exception as e:
            return
        
        if current_layers != layers:
            self.processor = None
            
            try:
                self.processor = SHPProcessor(current_layers)
            except Exception as e:
                return
        else:
            return
        
    def create_scratch_layer(self, name, geom_type):
        crs = "EPSG:3844"
        if geom_type == "Point":
            uri = f"Point?crs={crs}"
        elif geom_type == "LineString":
            uri = f"LineString?crs={crs}"
        else:
            uri = f"None?crs={crs}"

        layer = QgsVectorLayer(uri, name, "memory")
        provider = layer.dataProvider()

        fields = QgsFields()
        fields.append(QgsField("nume_layer", QVariant.String))  
        fields.append(QgsField("coloane", QVariant.String))     
        fields.append(QgsField("feature_id", QVariant.Int))
        provider.addAttributes(fields)
        layer.updateFields()
        return layer