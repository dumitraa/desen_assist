# -*- coding: utf-8 -*-
"""
/***************************************************************************
 DesenAssist
                                 A QGIS plugin
 Helps in assisting for Desen
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2024-11-29
        git sha              : $Format:%H$
        copyright            : (C) 2024 by Ionela
        email                : ioneladumitra@yahoo.ro
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

from collections import defaultdict
import colorsys
import os
import os.path
from pathlib import Path
import random
import re

from PyQt5.QtCore import QVariant  # type: ignore
from qgis.PyQt.QtCore import QCoreApplication, QSettings, QTranslator, QVariant  # type: ignore
from qgis.PyQt.QtGui import QColor, QIcon  # type: ignore
from qgis.PyQt.QtWidgets import QAction, QFileDialog, QInputDialog, QMessageBox  # type: ignore
import processing  # type: ignore

from qgis.core import ( # type: ignore
    Qgis,
    QgsCategorizedSymbolRenderer,
    QgsFeature,
    QgsFeatureRequest,
    QgsField,
    QgsFields,
    QgsGeometry,
    QgsMessageLog,
    QgsPointXY,
    QgsProcessingContext,
    QgsProject,
    QgsSymbol,
    QgsCategorizedSymbolRenderer,
    QgsRendererCategory,
    QgsSpatialIndex,
    QgsVectorFileWriter,
    QgsVectorLayer,
    QgsWkbTypes,
    QgsFeatureRequest
)

# Local imports
from . import config
from .func.generate_excel import GenerateExcelDialog
from .func.helper_functions import HelperBase, SHPProcessor
from .resources import *


class DesenAssist:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        self.context = QgsProcessingContext()
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        self.helper = HelperBase()
        self.processor = None
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'DesenAssist_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&DesenAssist')
        
        self.layers = self.helper.get_layers()

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None


    @staticmethod
    def plugin_path(*args) -> Path:
        """ Return the path to the plugin root folder or file. """
        path = Path(__file__).resolve().parent
        for item in args:
            path = path.joinpath(item)
        return path


    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('DesenAssist', message)


    def add_action(
        self,
        name,
        text,
        callback=None,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None,
        icon_path=None,
        shortcut=None,):
        
        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.setEnabled(enabled_flag)

        if callback is not None:
            action.triggered.connect(callback)
            action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)
            
        if shortcut is not None:
            action.setShortcut(shortcut)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            self.toolbar.addAction(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action


    def initGui(self):
        self.toolbar = self.iface.addToolBar('DesenAssist')
        self.toolbar.setObjectName('DesenAssist')
        self.toolbar.setMovable(True)
        
        self.fisier_destinatie_action = self.add_action(
            "Fisier Destinatie",
            text=self.tr(u'Fisier Destinatie'),
            callback=self.set_base_dir,
            parent=self.iface.mainWindow(),
            icon_path= str(self.plugin_path('icons/folder.png')),
            enabled_flag=True
        )
                
        self.actions_to_enable = [
            self.add_action(
                "Separare posturi dupa ID_BDI",
                text=self.tr(u'Separare posturi dupa ID_BDI'),
                callback=self.prepare_and_separate,
                parent=self.iface.mainWindow(),
                icon_path= str(self.plugin_path('icons/separate.png')),
                enabled_flag=False
            ),
            self.add_action(
                "Ajustare bransament BPMP la 1m",
                text=self.tr(u'Ajustare bransament BPMP la 1m'),
                callback=self.cut_bpmp,
                parent=self.iface.mainWindow(),
                icon_path= str(self.plugin_path('icons/cut.png')),
                enabled_flag=True
            ),
            self.add_action(
                "Verificare numerotare stâlpi",
                text=self.tr(u'Verificare numerotare stâlpi'),
                callback=self.verify_pole_numbering,
                parent=self.iface.mainWindow(),
                icon_path= str(self.plugin_path('icons/1.png')),
                enabled_flag=True
            ),
            self.add_action(
                "Verificare denumire străzi - STALP_JT",
                text=self.tr(u'Verificare denumire străzi - STALP_JT'),
                callback=self.verify_street_names_poles,
                parent=self.iface.mainWindow(),
                icon_path= str(self.plugin_path('icons/2.png')),
                enabled_flag=True
            ),
            self.add_action(
                "Actualizare denumiri străzi - STALP_JT",
                text=self.tr(u'Actualizare denumiri străzi - STALP_JT'),
                callback=self.update_street_stalp,
                parent=self.iface.mainWindow(),
                icon_path= str(self.plugin_path('icons/3.png')),
                enabled_flag=True
            ),
            self.add_action(
                "Actualizare denumiri străzi - BRANS_FIRI_GRPM_JT",
                text=self.tr(u'Actualizare denumiri străzi - BRANS_FIRI_GRPM_JT'),
                callback=self.update_street_brans,
                parent=self.iface.mainWindow(),
                icon_path= str(self.plugin_path('icons/4.png')),
                enabled_flag=True
            ),
            self.add_action(
                "Corespondență LINIA_JT - TRONSON_JT cu BRANS_FIRI_GRPM_JT",
                text=self.tr(u'Corespondență LINIA_JT - TRONSON_JT cu BRANS_FIRI_GRPM_JT'),
                callback=self.verify_linia_jt_matches,
                parent=self.iface.mainWindow(),
                icon_path= str(self.plugin_path('icons/5.png')),
                enabled_flag=True
            ),
            self.add_action(
                "Actualizare TIP_BR - BRANS_FIRI_GRPM_JT",
                text=self.tr(u'Actualizare TIP_BR - BRANS_FIRI_GRPM_JT'),
                callback=self.update_branch_fields,
                parent=self.iface.mainWindow(),
                icon_path= str(self.plugin_path('icons/6.png')),
                enabled_flag=True
            ),
            self.add_action(
                "Actualizare PROP - STALP_JT",
                text=self.tr(u'Actualizare PROP - STALP_JT'),
                callback=self.update_prop_column,
                parent=self.iface.mainWindow(),
                icon_path= str(self.plugin_path('icons/7.png')),
                enabled_flag=True
            ),
            self.add_action(
                "Verificare coloane obligatorii",
                text=self.tr(u'Verificare coloane obligatorii'),
                callback=self.verify_mandatory_columns,
                parent=self.iface.mainWindow(),
                icon_path= str(self.plugin_path('icons/8.png')),
                enabled_flag=True
            ),
            self.add_action(
                "Verificare circuit greșit",
                text=self.tr(u'Verificare circuit greșit'),
                callback=self.verify_circuit,
                parent=self.iface.mainWindow(),
                icon_path= str(self.plugin_path('icons/9.png')),
                enabled_flag=True
            ),
            self.add_action(
                "Verificare greseli (coloane alfanumerice, colerari gresite) - STALP_JT",
                text=self.tr(u'Verificare greseli'),
                callback=self.verify_mistakes,
                parent=self.iface.mainWindow(),
                icon_path= str(self.plugin_path('icons/10.png')),
            ),
            self.add_action(
                "Verificare strazi si generare excel",
                text=self.tr(u'Verificare strazi si generare excel'),
                callback=self.verify_streets,
                parent=self.iface.mainWindow(),
                icon_path= str(self.plugin_path('icons/excel.png')),
                enabled_flag=False
            )
        ]
        
        # will be set False in run()
        self.first_start = True


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(self.tr(u'&Desen Assist'), action)
            self.toolbar.removeAction(action)
        del self.toolbar
        
    def set_base_dir(self):
        project = QgsProject.instance()
        missing_layers = []
        layers = {}
        
        required_layers = ["BRANS_FIRI_GRPM_JT", "FB pe C LES", "TRONSON_JT", "STALP_JT", "LINIE_JT"]
        
        for layer_name in required_layers:
            found_layers = project.mapLayersByName(layer_name)
            if not found_layers:
                missing_layers.append(layer_name)
            else:
                layers[layer_name] = found_layers[0]
        
        if missing_layers:
            missing_str = ", ".join(missing_layers)
            QMessageBox.critical(None, "Eroare", f"Urmatoarele straturi lipsesc: {missing_str}")
            return

        self.layers = layers
        
        base_dir = QFileDialog.getExistingDirectory(None, "Selectați folder-ul de bază", "")
        if base_dir:
            self.base_dir = base_dir
            self.fisier_destinatie_action.setIcon(QIcon(str(self.plugin_path('icons/complete.png'))))
            for action in self.actions_to_enable:
                action.setEnabled(True)

        
    def get_layer_path(self, layer_name):
        """
        Get the full data source path of a layer by its name.

        Parameters:
            layer_name (str): The name of the layer in the QGIS project.

        Returns:
            str: The full data source path of the layer, including `|layername=`.
                Returns None if the layer is not found.
        """
        # Search for the layer by name in the current project
        layers = QgsProject.instance().mapLayersByName(layer_name)
        if not layers:
            return None
        
        # Get the first matching layer
        layer = layers[0]
        # Extract the data source path
        data_source = layer.dataProvider().dataSourceUri()
        
        # Append layername (important for GPKG files with multiple layers)
        if layer.storageType() == "GeoPackage" and "|layername=" not in data_source:
            data_source += f"|layername={layer.name()}"
        
        return data_source

    def clean_denum(self, denum):
        denum = str(denum)
        if denum:
            # Extract numeric and alphabetic parts
            match = re.match(r'(\d+)([A-Za-z]*)', denum)
            if match:
                numeric_part = int(match.group(1))  # Numeric part
                alpha_part = match.group(2).upper()  # Alphabetic part (uppercased)
                return (numeric_part, alpha_part)
        return (float('inf'), '')  # Non-matching cases go to the end

    # Process Layers
    def process_layers(self, layers):
        if not self.processor:
            try:
                self.processor = SHPProcessor(layers)
            except Exception as e:
                return
        
        try:
            current_layers = self.helper.get_layers()
        except Exception as e:
            return
        
        if current_layers != layers:
            self.processor = None
            
            try:
                self.processor = SHPProcessor(current_layers)
            except Exception as e:
                return
        else:
            return
        
    def create_scratch_layer(self, name, geom_type):
        crs = "EPSG:3844"
        if geom_type == "Point":
            uri = f"Point?crs={crs}"
        elif geom_type == "LineString":
            uri = f"LineString?crs={crs}"
        else:
            uri = f"None?crs={crs}"

        layer = QgsVectorLayer(uri, name, "memory")
        provider = layer.dataProvider()

        fields = QgsFields()
        fields.append(QgsField("nume_layer", QVariant.String))  
        fields.append(QgsField("coloane", QVariant.String))     
        fields.append(QgsField("feature_id", QVariant.Int))
        provider.addAttributes(fields)
        layer.updateFields()
        return layer

    def prepare_and_separate(self):
        success = self.assign_id_bdis(self.layers)
        
        if success:
            self.separate_poles_by_id(self.layers)
        else:
            QMessageBox.warning(None, "Eroare", "Eroare la asignarea ID_BDI")
    
    def assign_id_bdis(self, layers):
        """
        Completes ID_BDI for BRANS_FIRI_GRPM_JT, FB_pe_C_LES, TRONSON_JT by mapping from their LINIE_JT - which corresponds to DENUM from layer LINIA_JT (which also has ID_BDI)
        Completes ID_BDI for STALP_JT by getting the intersected TRONSON_JT's ID_BDI. If multiple intersecting TRONSON_JT features have different ID_BDI values, assign the most frequent one.
        If no intersection is found in TRONSON_JT, checks for intersections in BRANS_FIRI_GRPM_JT.
        """
        
        # Create dictionary for LINIE_JT mapping (DENUM -> ID_BDI)
        linia_jt_layer = layers["LINIE_JT"]
        linia_jt_mapping = {feat["DENUM"]: feat["ID_BDI"] for feat in linia_jt_layer.getFeatures()}
        
        # Update ID_BDI for BRANS_FIRI_GRPM_JT, FB pe C LES, TRONSON_JT based on LINIA_JT
        for layer_name in ["BRANS_FIRI_GRPM_JT", "FB pe C LES", "TRONSON_JT"]:
            layer = layers[layer_name]
            layer.startEditing()
            for feature in layer.getFeatures():
                linia_denum = feature["LINIA_JT"]
                if linia_denum in linia_jt_mapping:
                    feature["ID_BDI"] = linia_jt_mapping[linia_denum]
                    layer.updateFeature(feature)
            layer.commitChanges()
        
        # Spatially join ID_BDI from TRONSON_JT to STALP_JT
        tronson_jt_layer = layers["TRONSON_JT"]
        bransament_jt_layer = layers["BRANS_FIRI_GRPM_JT"]
        stalp_jt_layer = layers["STALP_JT"]
        
        spatial_index_tr = QgsSpatialIndex(tronson_jt_layer.getFeatures())
        spatial_index_br = QgsSpatialIndex(bransament_jt_layer.getFeatures())
        
        stalp_jt_layer.startEditing()
        for stalp in stalp_jt_layer.getFeatures():
            intersecting_ids_tr = spatial_index_tr.intersects(stalp.geometry().boundingBox())
            
            id_bdi_value = None  # Store found ID_BDI
            
            # First, try to get ID_BDI from intersecting TRONSON_JT
            if intersecting_ids_tr:
                for tronson in tronson_jt_layer.getFeatures(QgsFeatureRequest().setFilterFids(intersecting_ids_tr)):
                    if stalp.geometry().intersects(tronson.geometry()):
                        id_bdi_value = tronson["ID_BDI"]
                        if id_bdi_value:  # If found, no need to check further
                            break
            
            # If no ID_BDI found in TRONSON_JT, check BRANS_FIRI_GRPM_JT
            if not id_bdi_value:
                intersecting_ids_br = spatial_index_br.intersects(stalp.geometry().boundingBox())
                
                if intersecting_ids_br:
                    for bransament in bransament_jt_layer.getFeatures(QgsFeatureRequest().setFilterFids(intersecting_ids_br)):
                        if stalp.geometry().intersects(bransament.geometry()):
                            id_bdi_value = bransament["ID_BDI"]
                            if id_bdi_value:
                                break  # Stop as soon as one is found
            
            # Assign the found ID_BDI to the STALP_JT feature
            if id_bdi_value:
                stalp["ID_BDI"] = id_bdi_value
                stalp_jt_layer.updateFeature(stalp)

        stalp_jt_layer.commitChanges()
        return True


    def separate_poles_by_id(self, layers):
        """
        Filters all layers based on user-input ID_BDI values and exports them into single .gpkg files per layer type.
        """
        # Get ID_BDI from user
        id_bdis, ok = QInputDialog.getText(None, "Input ID_BDI", "ID_BDI:")
        if not ok or not id_bdis:
            QMessageBox.warning(None, "Input Error", "ID_BDI nu a fost introdus.")
            return
        
        # Convert input IDs to a list
        id_bdi_list = [id_bdi.strip() for id_bdi in id_bdis.split(",") if id_bdi.strip()]
        
        # Access the layers
        linie_jt_layer = layers["LINIE_JT"]
        stalp_jt_layer = layers["STALP_JT"]
        brans_layer = layers["BRANS_FIRI_GRPM_JT"]
        fb_les_layer = layers["FB pe C LES"]
        tronson_layer = layers["TRONSON_JT"]
        
        # Define layers to filter
        layers_to_filter = {
            "LINIE_JT": linie_jt_layer,
            "STALP_JT": stalp_jt_layer,
            "BRANS_FIRI_GRPM_JT": brans_layer,
            "FB pe C LES": fb_les_layer,
            "TRONSON_JT": tronson_layer
        }
        
        base_dir = self.base_dir
        if not os.path.exists(base_dir):
            os.makedirs(base_dir)
        
        # Create a new group in QGIS
        root = QgsProject.instance().layerTreeRoot()
        new_group = root.addGroup(f"Date_Filtrate_{'_'.join(id_bdi_list)}")
        
        missing_id_bdis = []
        
        for id_bdi in id_bdi_list:
            found = False
            for feature in linie_jt_layer.getFeatures():
                if str(feature["ID_BDI"]) == id_bdi:
                    found = True
                    break
            if not found:
                missing_id_bdis.append(id_bdi)
        
        for layer_name, original_layer in layers_to_filter.items():
            # Retrieve geometry type and CRS
            geometry_type = QgsWkbTypes.displayString(original_layer.wkbType())
            crs = original_layer.crs().authid()
            
            # Create a new in-memory layer
            new_layer = QgsVectorLayer(f"{geometry_type}?crs={crs}", layer_name, "memory")
            new_layer_data = new_layer.dataProvider()
            new_layer_data.addAttributes(original_layer.fields())
            new_layer.updateFields()
            
            # Collect all matching features
            matching_features = []
            for feature in original_layer.getFeatures():
                if str(feature["ID_BDI"]) in id_bdi_list:
                    matching_features.append(QgsFeature(feature))
            
            # Add filtered features to new layer (even if empty)
            new_layer_data.addFeatures(matching_features)
            new_layer.updateExtents()
            
            # Export to GeoPackage
            output_path = os.path.join(base_dir, f"{layer_name}.gpkg")
            QgsVectorFileWriter.writeAsVectorFormat(
                new_layer, output_path, "UTF-8", original_layer.crs(), "GPKG"
            )
            
            # Add to QGIS and group
            QgsProject.instance().addMapLayer(new_layer, False)
            new_group.addLayer(new_layer)
        
        QMessageBox.information(None, "Success", "Layerele filtrate au fost salvate cu succes")
        
        if missing_id_bdis:
            QMessageBox.warning(None, "ID_BDI lipsă în LINIE_JT", f"ID_BDI lipsă în LINIE_JT: {', '.join(missing_id_bdis)}")


    def cut_bpmp(self):
        # Retrieve the layers
        br_layer = QgsProject.instance().mapLayersByName("BRANS_FIRI_GRPM_JT")[0]
        st_layer = QgsProject.instance().mapLayersByName("STALP_JT")[0]

        # Define field names to check
        br_field = "TIP_FIRI_BR"
        cond_field = "TIP_COND"

        # Start an edit session on the br_layer if not already in one
        if not br_layer.isEditable():
            br_layer.startEditing()

        # Iterate through each feature
        for feat in br_layer.getFeatures():
            # Apply condition: check if the field value is BMPM or BMPT
            # and that TIP_COND is not 'ACYABY 4x16'
            if feat[br_field] in ("BMPM", "BMPT") and feat[cond_field] != "ACYABY 4x16":
                geom = feat.geometry()
                # Ensure we are dealing with a simple polyline (skip multipart for now)
                if geom.isMultipart():
                    # Optionally handle multipart geometries here
                    print(f"Skipping feature {feat.id()} because it is multipart.")
                    continue

                points = geom.asPolyline()
                # Require at least two vertices to define a segment
                if len(points) < 2:
                    continue

                # Identify the last segment endpoints
                p_second_last = points[-2]
                p_last = points[-1]

                # Compute the current segment length
                current_length = p_second_last.distance(p_last)
                # Avoid division by zero
                if current_length == 0:
                    continue

                # Compute the normalized direction vector from the second-last to the last vertex
                dx = p_last.x() - p_second_last.x()
                dy = p_last.y() - p_second_last.y()
                norm = (dx**2 + dy**2)**0.5
                ndx = dx / norm
                ndy = dy / norm

                # The new last vertex is positioned 1 meter from the second-last vertex,
                # regardless of whether that means shortening or extending the segment.
                new_last = QgsPointXY(p_second_last.x() + ndx * 1.0,
                                    p_second_last.y() + ndy * 1.0)
                points[-1] = new_last

                # Reconstruct the geometry with the adjusted vertex
                new_geom = QgsGeometry.fromPolylineXY(points)
                # Update the feature's geometry in the layer
                br_layer.changeGeometry(feat.id(), new_geom)

        # Commit all changes made during the edit session
        br_layer.commitChanges()
        QMessageBox.information(None, "Success", "Bransamentele BMPM și BMPT au fost tăiate cu succes la 1 metru.")


# A.	Verificare numerotare stalpi
    def verify_pole_numbering(self):
        """
        Verifies and sorts a field numerically, adding an "order" column for verification.
        1. Refactor fields for STALP_JT layer - new scratch layer - "Verificare_numerotare_stalpi"
        2. Filter/only take into account features which has "JT" included in "TIP_CIR"
        3. Add a new field "ID_PROVIZ" to the layer
        4. Populate it with @row_number - 1 (for the filtered features)
        5. Create new column "MATCH_STATUS" and populate it with "Da" if "ID_PROVIZ" == "DENUM", else "Nu"
        """
        # Step 1: Get the original layer (replace 'layer_name' with your actual layer name)
        original_layer = QgsProject.instance().mapLayersByName("STALP_JT")[0]

        # Step 2: Filter features with "JT" in the "TIP_CIR" field
        jt_features = [f for f in original_layer.getFeatures() if "JT" in f["TIP_CIR"]]

        # Step 3: Create a new scratch layer
        scratch_layer = QgsVectorLayer(
            "Point?crs=" + original_layer.crs().toWkt(), 
            "Verificare_numerotare_stalpi", 
            "memory"
        )
        scratch_layer_data = scratch_layer.dataProvider()

        # Add only the necessary fields
        fields = QgsFields()
        fields.append(QgsField("fid", QVariant.Int))
        fields.append(QgsField("TIP_CIR", QVariant.String))
        fields.append(QgsField("ID_PROVIZ", QVariant.Int))
        fields.append(QgsField("DENUM", QVariant.String))
        fields.append(QgsField("MATCH_STATUS", QVariant.String))
        scratch_layer_data.addAttributes(fields)
        scratch_layer.updateFields()

        # Step 4: Populate the new layer with filtered features and compute new fields
        for idx, feature in enumerate(jt_features):
            new_feature = QgsFeature()
            new_feature.setGeometry(feature.geometry())
            new_feature.setFields(scratch_layer.fields())

            # Add new fields
            new_feature["fid"] = feature.id()
            new_feature["TIP_CIR"] = feature["TIP_CIR"]
            new_feature["ID_PROVIZ"] = idx  # Row number starts at 0
            new_feature["DENUM"] = feature["DENUM"]
            new_feature["MATCH_STATUS"] = "Da" if int(new_feature["ID_PROVIZ"]) == int(feature["DENUM"]) else "Nu"

            # Add feature to the scratch layer
            scratch_layer_data.addFeature(new_feature)

        # Add the scratch layer to the project
        QgsProject.instance().addMapLayer(scratch_layer)
        
        # self.verify_pole_numbering_br()
        # self.verify_pole_numbering_jt()
        # QMessageBox.information(None, "Verificare numerotare stâlpi", "Verificare finalizată cu succes! Stâlpii au fost sortați și numerotați corect.")

    def verify_pole_numbering_br(self):
        """
        Verifies and sorts features numerically by the alphanumeric value of DENUM.
        Also, ensures DENUM values are uppercased and modifies the original layer for "JT" features.
        """
        original_layer = QgsProject.instance().mapLayersByName("STALP_JT")[0]

        # Uppercase the DENUM field in the original layer and save changes
        original_layer.startEditing()
        for feature in original_layer.getFeatures():
            denum = feature["DENUM"]
            if denum:
                feature["DENUM"] = denum.upper()
                original_layer.updateFeature(feature)
        original_layer.commitChanges()

        jt_features = [f for f in original_layer.getFeatures() if re.search(r'[A-Za-z]', str(f["DENUM"]))]
        jt_features_sorted = sorted(jt_features, key=lambda f: self.clean_denum(f["DENUM"]))

        # Create a new scratch layer for BR features
        scratch_layer = QgsVectorLayer(
            "Point?crs=" + original_layer.crs().toWkt(),
            "Verificare_auxiliari",
            "memory"
        )
        scratch_layer_data = scratch_layer.dataProvider()

        # Add only the necessary fields
        fields = QgsFields()
        fields.append(QgsField("fid", QVariant.Int))  # Original feature ID
        fields.append(QgsField("TIP_CIR", QVariant.String))
        fields.append(QgsField("DENUM", QVariant.String))
        scratch_layer_data.addAttributes(fields)
        scratch_layer.updateFields()

        # Populate the new layer with sorted features and compute new fields
        for idx, feature in enumerate(jt_features_sorted):  # Enumerate in the sorted DENUM order
            new_feature = QgsFeature()
            new_feature.setGeometry(feature.geometry())
            new_feature.setFields(scratch_layer.fields())

            # Add new fields
            new_feature["fid"] = feature.id()
            new_feature["TIP_CIR"] = feature["TIP_CIR"]
            new_feature["DENUM"] = feature["DENUM"]

            # Add feature to the scratch layer
            scratch_layer_data.addFeature(new_feature)

        # Add the scratch layer to the project
        QgsProject.instance().addMapLayer(scratch_layer)


    def verify_pole_numbering_jt(self):
        """
        Normalizes DENUM fields in the STALP_JT layer (features where TIP_CIR includes 'JT') so that:
        - Consecutive duplicates with no suffix (e.g. 11, 11, 12) become 11, 12, 13
        - If there's a suffix involved (e.g. 11, 11A, 11A), everything shares the same base and suffixes start at A:
            e.g. => 11, 11A, 11B
        - Ensures base numbers are sequential with no gaps (e.g. 41, 43 becomes 41, 42)
        """

        original_layer = QgsProject.instance().mapLayersByName("STALP_JT")[0]
        jt_features = [f for f in original_layer.getFeatures() if "JT" in f["TIP_CIR"]]

        denum_map = {}
        for feat in jt_features:
            feature_id = feat.id()
            base_suffix = self.clean_denum(feat["DENUM"])  # returns (base_int, suffix_str)
            denum_map[feature_id] = base_suffix

        sorted_items = sorted(denum_map.items(), key=lambda x: (x[1][0], x[1][1]))

        assigned_bases = set()
        base_suffix_count = defaultdict(int)
        final_assignments = {}
        
        all_bases = sorted(set(base for _, (base, _) in sorted_items))
        min_base = all_bases[0] if all_bases else 1
        
        def next_unused_base(candidate, used_bases):
            """Finds the next available base number without gaps."""
            while candidate in used_bases:
                candidate += 1
            return candidate

        sequential_bases = {old: new for old, new in zip(all_bases, range(min_base, min_base + len(all_bases)))}
        
        for feat_id, (base, suffix) in sorted_items:
            suffix = suffix.upper()
            new_base = sequential_bases[base]  # Remap base to sequential numbering
            
            if new_base not in assigned_bases:
                final_assignments[feat_id] = (new_base, "")
                assigned_bases.add(new_base)
                base_suffix_count[new_base] = 0
            else:
                if suffix == "":
                    new_base = next_unused_base(new_base, assigned_bases)
                    final_assignments[feat_id] = (new_base, "")
                    assigned_bases.add(new_base)
                    base_suffix_count[new_base] = 0
                else:
                    cur_count = base_suffix_count[new_base]
                    letter = chr(65 + cur_count)  # 65 is 'A'
                    final_assignments[feat_id] = (new_base, letter)
                    base_suffix_count[new_base] = cur_count + 1

        original_layer.startEditing()

        for feat_id, (new_base, new_suffix) in final_assignments.items():
            new_denum = f"{new_base}{new_suffix}"
            try:
                feature = original_layer.getFeature(feat_id)
                feature["DENUM"] = new_denum
                original_layer.updateFeature(feature)
            except Exception as e:
                QgsMessageLog.logMessage(
                    f"Error updating feature {feat_id} -> {new_base}{new_suffix}: {e}",
                    'DesenAssist',
                    Qgis.Critical
                )

        original_layer.commitChanges()


#. B.	Denumirea strazilor pentru stalpi - TO FURTHER TEST
    def update_street_stalp(self):
        """
        Updates the STR field in the STALP_JT layer by finding intersecting
        street features from the 'strazi' layer and assigning their cleaned
        DENUMIRE_D value.
        """
        # Retrieve layers
        stalp_layers = QgsProject.instance().mapLayersByName("STALP_JT")
        strazi_layers = QgsProject.instance().mapLayersByName("strazi")
        
        missing_layers = []
        if not stalp_layers:
            missing_layers.append("STALP_JT")
        if not strazi_layers:
            missing_layers.append("strazi")
        if missing_layers:
            QMessageBox.critical(None, "Eroare", f"Urmatoarele straturi lipsesc: {', '.join(missing_layers)}")
            return
        
        stalp_layer = stalp_layers[0]
        strazi_layer = strazi_layers[0]
        
        # Create a spatial index for the street layer to speed up spatial queries.
        spatial_index = QgsSpatialIndex(strazi_layer.getFeatures())
        
        # Ensure STALP_JT is in edit mode.
        if not stalp_layer.isEditable():
            stalp_layer.startEditing()
        
        # Iterate over each pole feature.
        for pole in stalp_layer.getFeatures():
            geom = pole.geometry()
            # Optionally, if you need a bit of a buffer, uncomment the next line:
            geom = geom.buffer(10, 5)
            
            # Get candidate street features whose bounding boxes intersect.
            candidate_ids = spatial_index.intersects(geom.boundingBox())
            street_name = None
            
            for fid in candidate_ids:
                street_feature = strazi_layer.getFeature(fid)
                if geom.intersects(street_feature.geometry()):
                    # Clean the street name.
                    raw_name = street_feature["DENUMIRE_D"]
                    cleaned = (
                        raw_name.replace('ă', 'a').replace('â', 'a').replace('Ă', 'A')
                            .replace('î', 'i').replace('Î', 'I')
                            .replace('ș', 's').replace('Ș', 'S')
                            .replace('Ş', 'S').replace('ş', 's')
                            .replace('ț', 't').replace('Ț', 'T')
                            .replace('Ţ', 'T').replace('ţ', 't')
                            .replace('Strada ', '')
                    )
                    street_name = cleaned.upper()
                    break  # Use the first matching street
            
            # If a street was found, update the STR field.
            if street_name:
                pole["STR"] = street_name
                stalp_layer.updateFeature(pole)
        
        # Commit changes and provide feedback.
        if stalp_layer.commitChanges():
            QMessageBox.information(None, "STR - STALP_JT", "Denumirile străzilor pentru stalpi au fost actualizate cu succes.")
        else:
            QMessageBox.critical(None, "Eroare", "Eroare la actualizarea denumirilor străzilor pentru stalpi.")


# C.	Coloana “linie jt” sa fie la fel la bransament si la tronson - WORKING
    def verify_linia_jt_matches(self):
        '''
        Checks for mismatched LINIA_JT values between intersecting features
        in BRANS_FIRI_GRPM_JT and TRONSON_JT layers.
        For every BRANS feature, each intersecting TRONSON feature is examined.
        If the LINIA_JT values differ, a record is added to a scratch layer.
        The scratch layer contains three fields:
        "fid" - the BRANS feature ID,
        "TRONSON_JT_LINIA_JT" - the LINIA_JT value from the TRONSON feature,
        "BRANSAMENT_LINIA_JT" - the LINIA_JT value from the BRANS feature.
        '''
        # Load layers
        brans_layers = QgsProject.instance().mapLayersByName('BRANS_FIRI_GRPM_JT')
        tronson_layers = QgsProject.instance().mapLayersByName('TRONSON_JT')
        
        missing_layers = []
        if not brans_layers:
            missing_layers.append('BRANS_FIRI_GRPM_JT')
        if not tronson_layers:
            missing_layers.append('TRONSON_JT')
        if missing_layers:
            QMessageBox.critical(None, 'Eroare', f'Urmatoarele straturi lipsesc: {", ".join(missing_layers)}')
            return
        
        brans_layer = brans_layers[0]
        tronson_layer = tronson_layers[0]
        
        # Build a spatial index for TRONSON layer for efficient querying.
        tronson_index = QgsSpatialIndex(tronson_layer.getFeatures())
        
        mismatches = []
        
        # Iterate over each BRANS feature.
        for brans_feature in brans_layer.getFeatures():
            brans_linia = brans_feature["LINIA_JT"]
            if not brans_linia:
                continue
            brans_geom = brans_feature.geometry()
            
            # Find candidate TRONSON features that intersect the BRANS feature’s bounding box.
            candidate_ids = tronson_index.intersects(brans_geom.boundingBox())
            for cand_id in candidate_ids:
                tronson_feature = tronson_layer.getFeature(cand_id)
                if brans_geom.intersects(tronson_feature.geometry()):
                    tronson_linia = tronson_feature["LINIA_JT"]
                    # If the LINIA_JT values differ, record this mismatch.
                    if tronson_linia != brans_linia:
                        new_feature = QgsFeature()
                        new_feature.setGeometry(brans_geom)
                        new_feature.setAttributes([str(brans_feature.id()), tronson_linia, brans_linia])
                        mismatches.append(new_feature)
        
        if mismatches:
            # Create a scratch layer with the same geometry type and CRS as the BRANS layer.
            scratch_layer = QgsVectorLayer("LineString?crs=EPSG:3844", "LINIA_JT_verificare", "memory")
            fields = QgsFields()
            fields.append(QgsField("fid", QVariant.String))
            fields.append(QgsField("TRONSON_JT_LINIA_JT", QVariant.String))
            fields.append(QgsField("BRANSAMENT_LINIA_JT", QVariant.String))
            scratch_layer.dataProvider().addAttributes(fields)
            scratch_layer.updateFields()
            
            # Add the mismatched features to the scratch layer.
            scratch_layer.dataProvider().addFeatures(mismatches)
            scratch_layer.commitChanges()
            QgsProject.instance().addMapLayer(scratch_layer)
            
            QMessageBox.information(None, "LINIA_JT", 
                "Au fost gasite linii JT cu valori diferite intre BRANS_FIRI_GRPM_JT si TRONSON_JT.")
        else:
            QMessageBox.information(None, "LINIA_JT", 
                "Toate campurile de LINIA_JT corespund intre BRANS_FIRI_GRPM_JT si TRONSON_JT.")

        

# D.	Corelare campuri pentru bransamente – trifazat, monofazat - WORKING

    def update_branch_fields(self):
        """
        Updates the TIP_BR field in the 'BRANS_FIRI_GRPM_JT' layer based on the code in TIP_FIRI_BR.
        For codes 'FB1', 'FM1', 'BMPM', TIP_BR is set to 'monofazat'.
        For codes 'FB3', 'FM3', 'BMPT', TIP_BR is set to 'trifazat'.
        Otherwise, TIP_BR is set to 'Invalid Code'.
        """
        # Create a reverse mapping from code to branch type.
        code_to_branch = {
            "FB1": "monofazat",
            "FM1": "monofazat",
            "BMPM": "monofazat",
            "FB3": "trifazat",
            "FM3": "trifazat",
            "BMPT": "trifazat",
        }
        
        layer_list = QgsProject.instance().mapLayersByName("BRANS_FIRI_GRPM_JT")
        if not layer_list:
            QgsMessageLog.logMessage("Layer 'BRANS_FIRI_GRPM_JT' not found.", "DesenAssist", Qgis.Critical)
            return
        layer = layer_list[0]
        
        if not layer.isEditable():
            layer.startEditing()
            
        vague = False
        
        for feature in layer.getFeatures():
            code = feature["TIP_FIRI_BR"]
            tip_cond = feature["TIP_COND"]
            
            fdcs_tip_cond_trifazat = ["TYIR 3X25Al + 16Al", "AFYI 4x16"]
            fdcp_tip_cond_trifazat = ["TYIR 3X25Al + 16Al", "ACBYCY 16/16"]
            
            if code in code_to_branch:
                branch_value = code_to_branch[code]
            elif tip_cond in fdcs_tip_cond_trifazat and code == "FDCS":
                branch_value = "trifazat"
            elif tip_cond in fdcp_tip_cond_trifazat and code == "FDCP":
                branch_value = "trifazat"
            else:
                branch_value = "monofazat"
                
            if code == "FDCS" and tip_cond == "ACYABY 4x16":
                vague = True
            
            if branch_value:
                feature["TIP_BR"] = branch_value
            layer.updateFeature(feature)
        
        if layer.commitChanges():
            QMessageBox.information(None, "TIP_BR", "Campul TIP_BR a fost actualizat cu succes.")
            if vague:
                QMessageBox.critical(None, "AVERTIZARE", "⚠️ A fost gasit un caz special pentru FDCS si ACYABY 4x16! Verificati si completati manual.")
        else:
            QMessageBox.critical(None, "TIP_BR", "Eroare la actualizarea campului TIP_BR.")

        

# E.	Verificare denumiri strazi bransamente - WORKING
    def update_street_brans(self):
        # Hardcoded layer names
        brans_layer_name = "BRANS_FIRI_GRPM_JT"
        stalp_layer_name = "STALP_JT"

        # Retrieve layers from the project
        brans_layers = QgsProject.instance().mapLayersByName(brans_layer_name)
        stalp_layers = QgsProject.instance().mapLayersByName(stalp_layer_name)

        # Ensure both layers are loaded
        missing_layers = []
        if not brans_layers:
            missing_layers.append(brans_layer_name)
        if not stalp_layers:
            missing_layers.append(stalp_layer_name)
            
        if missing_layers:
            QMessageBox.critical(None, "Eroare", f"Urmatoarele straturi lipsesc: {', '.join(missing_layers)}")
            return

        brans_layer = brans_layers[0]
        stalp_layer = stalp_layers[0]

        # Ensure the BRANS layer is editable
        if not brans_layer.isEditable():
            brans_layer.startEditing()

        # Build a spatial index for the STALP layer to improve performance
        stalp_index = QgsSpatialIndex(stalp_layer.getFeatures())

        # Verify the BRANS layer has the STR field
        brans_field_index = brans_layer.fields().lookupField("STR")
        if brans_field_index == -1:
            QgsMessageLog.logMessage("Field 'STR' not found in BRANS layer.", 'DesenAssist', Qgis.Warning)
            return

        # Iterate over each feature in the BRANS layer
        for brans_feat in brans_layer.getFeatures():
            geom = brans_feat.geometry()

            # Get candidate STALP feature IDs using the bounding box of the current BRANS feature
            candidate_ids = stalp_index.intersects(geom.boundingBox())

            # Look for the first STALP point that intersects the BRANS line
            for cand_id in candidate_ids:
                cand_feat = stalp_layer.getFeature(cand_id)
                cand_geom = cand_feat.geometry()
                if geom.intersects(cand_geom):
                    new_str = cand_feat["STR"]
                    brans_layer.dataProvider().changeAttributeValues({
                        brans_feat.id(): {brans_field_index: new_str}
                    })
                    break  # Use only the first intersecting STALP point

        # Commit the changes after processing all features
        brans_layer.commitChanges()

        
        QMessageBox.information(None, "STR - BRANS_FIRI_GRPM_JT", "Denumirile străzilor pentru bransamente au fost actualizate cu succes.")


        
# F.	Completare automata a coloanei “PROP” de la STALP_JT - WORKING

    def update_prop_column(self):
        """
        Updates the PROP field in the 'STALP_JT' layer based on the DESC_CTG_MT_JT field.
        If DESC_CTG_MT_JT is in the terti_codes list, PROP is set to 'TERTI';
        if it's in the electrica_codes list, PROP is set to 'ELECTRICA'.
        """
        layers = QgsProject.instance().mapLayersByName('STALP_JT')
        if not layers:
            QgsMessageLog.logMessage("Layer 'STALP_JT' not found.", 'DesenAssist', Qgis.Critical)
            return
        layer = layers[0]

        # Begin editing if not already in edit mode.
        if not layer.isEditable():
            layer.startEditing()

        # Define the lists of codes.
        terti_codes = [
            'St. lemn tip SU', 'St. lemn tip SG', 'St. metalic rotund',
            'St. octogonal zincat sustinere', 'St. octogonal zincat intindere'
        ]
        electrica_codes = [
            'S 8 - U', 'S 9 - U', 'S 10 - U', 'S 10 - M', 'S 12 - M', 'S 10 - G',
            'S 11 - G', 'S 12 - G', 'S 13 - G', 'S 14 - G', 'SE 1A', 'SE 2', 'SE 3',
            'SE 4', 'SE 5', 'SE 6', 'SE 7', 'SE 8', 'SE 9', 'SE 10', 'SE 11',
            'SC 10001', 'SC 10002', 'SC 10005', 'SC 15004', 'SC 15006', 'SC 15007',
            'SC 15014-10.5', 'SC 15014', 'SI 9', 'SV 10001', 'SV 10002'
        ]

        # Process each feature.
        for feature in layer.getFeatures():
            desc_value = feature['DESC_CTG_MT_JT']
            expected_prop = None

            if desc_value in terti_codes:
                expected_prop = 'TERTI'
            elif desc_value in electrica_codes:
                expected_prop = 'ELECTRICA'
            else:
                # If the description is not in any known list, skip updating.
                continue

            # Only update if the current PROP doesn't match the expected value.
            if feature['PROP'] != expected_prop:
                feature['PROP'] = expected_prop
                layer.updateFeature(feature)

        # Commit the changes and notify the user.
        if layer.commitChanges():
            QMessageBox.information(None, "PROP", "Coloana PROP a fost actualizată cu succes.")
        else:
            QMessageBox.critical(None, "PROP", "Eroare la actualizarea coloanei PROP.")

    
    
 # G.	Verificarea denumirilor strazilor din layerul STALP_JT (layerul din renns va avea denumirea “nr_postale”) - WORKING
    
    def verify_street_names_poles(self):
        def normalize_text(text):
            replacements = {
                'ă': 'a', 'â': 'a', 'î': 'i', 'ș': 's', 'ş': 's', 'ț': 't', 'ţ': 't',
                'Ă': 'A', 'Â': 'A', 'Î': 'I', 'Ș': 'S', 'Ş': 'S', 'Ț': 'T', 'Ţ': 'T'
            }
            for diacritic, replacement in replacements.items():
                text = text.replace(diacritic, replacement)
            return text.upper()

        orig_layer = QgsProject.instance().mapLayersByName('STALP_JT')[0]
        nr_postale_layer = QgsProject.instance().mapLayersByName('nr_postale')[0]

        stalp_layer = QgsVectorLayer("Point?crs=EPSG:3844", "STALP_JT_verificare_denum", "memory")
        stalp_layer_data = stalp_layer.dataProvider()
        stalp_layer.startEditing()
        stalp_layer_data.addAttributes(orig_layer.fields())
        stalp_layer.updateFields()
        for feature in orig_layer.getFeatures():
            stalp_layer.addFeature(feature)
        stalp_layer.commitChanges()
        QgsProject.instance().addMapLayer(stalp_layer)

        if stalp_layer and nr_postale_layer:
            if 'MATCH_STATUS' not in [field.name() for field in stalp_layer.fields()]:
                stalp_layer.dataProvider().addAttributes([QgsField('MATCH_STATUS', QVariant.String)])
                stalp_layer.updateFields()

            denumire_d_values = set()
            for feature in nr_postale_layer.getFeatures():
                denumire_d = feature['DENUMIRE_D']
                if denumire_d:
                    denumire_d_values.add(normalize_text(denumire_d))
                
            stalp_layer.startEditing()

            for feature in stalp_layer.getFeatures():
                str_value = feature['STR']
                if str_value:
                    normalized_str = normalize_text(str_value)
                    if normalized_str not in denumire_d_values:
                        feature['MATCH_STATUS'] = 'Nu'
                    else:
                        feature['MATCH_STATUS'] = 'Da'
                    stalp_layer.updateFeature(feature)

        QgsProject.instance().write()
    
#. H.	Verificarea coloanelor unde campurile sunt obligatorii - WORKING
    def verify_mandatory_columns(self):
        layers_to_check = {
            "STALP_JT": [
                "DENUM", "NR_INS_STP", "PROP", "JUD", "PRIM", "LOC", "TIP_STR", "STR", 
                "TIP_CIR", "DESC_CTG_MT_JT", "NR_CIR", "UZURA_STP", "TIP_FUND", 
                "ADAOS", "TIP_LEG_JT", "fid"],
            "BRANS_FIRI_GRPM_JT": [
                "fid", "TIP_BR", "TIP_COND", "JUD", "PRIM", "LOC", "TIP_STR", "STR", 
                "NR_IMOB", "TIP_FIRI_BR", "LINIA_JT"],
            "TRONSON_JT": [
                "TIP_TR", "TIP_COND", "fid", "LINIA_JT"],
            "FB pe C LES": [
                "fid", "DENUM", "TIP_BR", "TIP_COND", "JUD", "PRIM", "LOC", "TIP_STR", 
                "STR", "NR_IMOB", "SURSA_COORD", "DATA_COORD", "TIP_FIRI_BR", "LINIA_JT"],
            "LINIE_JT": [
                "ID_BDI", "DENUM"]
        }

        layer_types = {
            "STALP_JT": "Point",
            "FB pe C LES": "Point",
            "TRONSON_JT": "LineString",
            "BRANS_FIRI_GRPM_JT": "LineString",
            "LINIE_JT": "None"
        }

        created_layers = {}

        for layer_name, columns in layers_to_check.items():
            layers = QgsProject.instance().mapLayersByName(layer_name.strip())
            if not layers:
                continue

            layer = layers[0]
            geom_type = layer_types[layer_name]

            scratch_layer = None
            for feature in layer.getFeatures():
                if layer_name == "STALP_JT":
                    incomplete_columns = set()
                    nr_cir_fo_val = feature['NR_CIR_FO']
                    prop_fo_val = feature['PROP_FO']
                    
                    if nr_cir_fo_val not in config.NULL_VALUES and prop_fo_val in config.NULL_VALUES:
                        incomplete_columns.add('PROP_FO (NR_CIR_FO e completat)')
                                
                    for column in columns:
                        if column not in [field.name() for field in layer.fields()]:
                            continue
                        value = feature[column]
                        if value in config.NULL_VALUES:
                            incomplete_columns.add(column)
                        
                if incomplete_columns:
                    if not scratch_layer:
                        scratch_layer = self.create_scratch_layer(f"{layer_name}_coloane_necompletate", geom_type)
                        created_layers[layer_name] = scratch_layer

                    new_feature = QgsFeature(scratch_layer.fields())
                    new_feature.setAttributes([
                        layer_name,                         
                        ", ".join(incomplete_columns),     
                        feature.id()                            
                    ])
                    if geom_type != "None":
                        geometry = feature.geometry()
                        if geometry and geometry.isGeosValid():
                            new_feature.setGeometry(geometry)
                            
                    scratch_layer.dataProvider().addFeature(new_feature)


        for name, layer in created_layers.items():
            QgsProject.instance().addMapLayer(layer)

# I.	Verificare circuit gresit - WORKING
    def verify_circuit(self):
        tronson_layer_name = "TRONSON_JT"
        tronson_layer = QgsProject.instance().mapLayersByName(tronson_layer_name)

        if not tronson_layer:
            return

        tronson_layer = tronson_layer[0]

        dissolve_params = {
            'INPUT': tronson_layer,
            'FIELD': ['LINIA_JT'],
            'OUTPUT': 'memory:',
        }
        dissolved_layer = processing.run("native:dissolve", dissolve_params)['OUTPUT']
        QgsProject.instance().addMapLayer(dissolved_layer)

        dissolved_layer.setName("Verificare_circuite")
        QgsProject.instance().addMapLayer(dissolved_layer)
        
        self.apply_categorization(dissolved_layer, "fid")
        
    def apply_categorization(self, layer, field_name):
            unique_values = layer.uniqueValues(layer.fields().lookupField(field_name))
            categories = []
            
            predefined_colors = [
                QColor(255, 0, 0), QColor(0, 255, 0), QColor(0, 0, 255),
                QColor(255, 255, 0), QColor(255, 165, 0), QColor(255, 20, 147),
                QColor(0, 255, 255), QColor(128, 0, 128), QColor(0, 128, 0),
                QColor(0, 0, 128), QColor(75, 0, 130), QColor(255, 105, 180)
            ]
            random.shuffle(predefined_colors)
            
            for i, value in enumerate(unique_values):
                if i >= len(predefined_colors):
                    break
                symbol = QgsSymbol.defaultSymbol(layer.geometryType())
                symbol.setColor(predefined_colors[i])
                symbol.setWidth(1.25)
                categories.append(QgsRendererCategory(value, symbol, str(value)))
            
            renderer = QgsCategorizedSymbolRenderer(field_name, categories)
            layer.setRenderer(renderer)
            layer.triggerRepaint()
        
    def verify_mistakes(self):
        self.verify_num_columns()
        self.verify_true_false_columns()
        
    # J.	Verificare numar coloane
    def verify_num_columns(self):
        layers_to_check = {
            "STALP_JT": [
                "UZURA_STP", "NR_CIR_FO", "NR_CIR_LTC", "NR_CIR_CATV", "NR_CONS_C2S", "NR_CONS_C4S", "NR_CONS_C2T", "NR_CONS_C4T", "NR_CONS_C2BR", "NR_CONS_C4BR"]
        }

        layer_types = {
            "STALP_JT": "Point",
        }

        created_layers = {}

        for layer_name, columns in layers_to_check.items():
            layers = QgsProject.instance().mapLayersByName(layer_name.strip())
            if not layers:
                continue

            layer = layers[0]
            geom_type = layer_types[layer_name]

            scratch_layer = None
            for feature in layer.getFeatures():
                incorrect_column = set()
                for column in columns:
                    if column not in [field.name() for field in layer.fields()]:
                        continue
                    value = feature[column]
                    if value not in config.NULL_VALUES:
                        try:
                            value = int(str(value))
                        except ValueError:
                            incorrect_column.add(column)

                if incorrect_column:
                    if not scratch_layer:
                        scratch_layer = self.create_scratch_layer(f"{layer_name}_coloane_gresite_nr", geom_type)
                        created_layers[layer_name] = scratch_layer

                    new_feature = QgsFeature(scratch_layer.fields())
                    new_feature.setAttributes([
                        layer_name,                         
                        ", ".join(incorrect_column),     
                        feature.id()                            
                    ])
                    if geom_type != "None":
                        geometry = feature.geometry()
                        if geometry and geometry.isGeosValid():
                            new_feature.setGeometry(geometry)
                            
                    scratch_layer.dataProvider().addFeature(new_feature)
        for _, layer in created_layers.items():
            QgsProject.instance().addMapLayer(layer)
            
    def verify_true_false_columns(self):
        columns_to_check = {
            "NR_CIR_FO": "FIB_OPT",
            "NR_CIR_LTC": "LTC",
            "NR_CIR_CATV": "CATV",
        }

        created_layers = {}

        layer = QgsProject.instance().mapLayersByName("STALP_JT")[0]

        scratch_layer = None
        for feature in layer.getFeatures():
            incorrect_columns = set()
            for key_field, bool_field in columns_to_check.items():
                if key_field not in [field.name() for field in layer.fields()] or bool_field not in [field.name() for field in layer.fields()]:
                    continue  # Skip if the key field or bool field is not present

                key_value = feature[key_field]  # Get the value of the key field
                bool_value = feature[bool_field]  # Get the value of the bool field

                # Check if key_value is completed (not null or empty)
                is_completed = key_value not in config.NULL_VALUES

                # Ensure the boolean value matches the expected logic
                if is_completed and bool_value.lower() not in [1, 'true', 'yes', 'da']:
                    incorrect_columns.add(bool_field)  # Expected "true" but got something else
                elif not is_completed and bool_value.lower() not in [0, 'false', 'no', 'nu']:
                    incorrect_columns.add(bool_field)  # Expected "false" but got something else

            if incorrect_columns:
                if not scratch_layer:
                    scratch_layer = self.create_scratch_layer(f"STALP_JT_coloane_gresite_bool", "Point")
                    created_layers["STALP_JT"] = scratch_layer

                new_feature = QgsFeature(scratch_layer.fields())
                new_feature.setAttributes([
                    "STALP_JT",                         
                    ", ".join(incorrect_columns),     
                    feature.id()                            
                ])
                geometry = feature.geometry()
                if geometry and geometry.isGeosValid():
                    new_feature.setGeometry(geometry)
                    
                scratch_layer.dataProvider().addFeature(new_feature)
        for _, layer in created_layers.items():
            QgsProject.instance().addMapLayer(layer)
            
    def verify_streets(self):
        self.process_layers(self.layers)
        dialog = GenerateExcelDialog(self.base_dir)
        dialog.exec_() 
        
