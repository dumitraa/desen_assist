# -*- coding: utf-8 -*-
"""
/***************************************************************************
 DesenAssist
                                 A QGIS plugin
 Helps in assisting for Desen
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2024-11-29
        git sha              : $Format:%H$
        copyright            : (C) 2024 by Ionela
        email                : ioneladumitra@yahoo.ro
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

from collections import defaultdict
import colorsys
import os
import os.path
from pathlib import Path
import random
import re

from PyQt5.QtCore import QVariant  # type: ignore
from qgis.PyQt.QtCore import QCoreApplication, QSettings, QTranslator, QVariant  # type: ignore
from qgis.PyQt.QtGui import QColor, QIcon  # type: ignore
from qgis.PyQt.QtWidgets import QAction, QFileDialog, QInputDialog, QMessageBox  # type: ignore
import processing  # type: ignore

from qgis.core import ( # type: ignore
    Qgis,
    QgsCategorizedSymbolRenderer,
    QgsFeature,
    QgsFeatureRequest,
    QgsField,
    QgsFields,
    QgsGeometry,
    QgsMessageLog,
    QgsPointXY,
    QgsProcessingContext,
    QgsProject,
    QgsSymbol,
    QgsCategorizedSymbolRenderer,
    QgsRendererCategory,
    QgsSpatialIndex,
    QgsVectorFileWriter,
    QgsVectorLayer,
    QgsWkbTypes,
    QgsFeatureRequest
)

# Local imports
from . import config
from .func.generate_excel import GenerateExcelDialog
from .func.helper_functions import HelperBase, SHPProcessor
from .resources import *


class DesenAssist:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        self.context = QgsProcessingContext()
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        self.helper = HelperBase()
        self.processor = None
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'DesenAssist_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&DesenAssist')
        
        self.layers = self.helper.get_layers()

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None


    @staticmethod
    def plugin_path(*args) -> Path:
        """ Return the path to the plugin root folder or file. """
        path = Path(__file__).resolve().parent
        for item in args:
            path = path.joinpath(item)
        return path


    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('DesenAssist', message)


    def add_action(
        self,
        name,
        text,
        callback=None,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None,
        icon_path=None,
        shortcut=None,):
        
        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.setEnabled(enabled_flag)

        if callback is not None:
            action.triggered.connect(callback)
            action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)
            
        if shortcut is not None:
            action.setShortcut(shortcut)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            self.toolbar.addAction(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        self.toolbar = self.iface.addToolBar('DesenAssist')
        self.toolbar.setObjectName('DesenAssist')
        self.toolbar.setMovable(True)
        
        self.fisier_destinatie_action = self.add_action(
            "Fisier Destinatie",
            text=self.tr(u'Fisier Destinatie'),
            callback=self.set_base_dir,
            parent=self.iface.mainWindow(),
            icon_path= str(self.plugin_path('icons/folder.png')),
            enabled_flag=True
        )
        self.actions_to_enable = [
            self.add_action(
                "Separare posturi dupa ID_BDI",
                text=self.tr(u'Separare posturi dupa ID_BDI'),
                callback=self.prepare_and_separate,
                parent=self.iface.mainWindow(),
                icon_path= str(self.plugin_path('icons/separate.png')),
                enabled_flag=False
            ),
            self.add_action(
                "Ajustare bransamente la 1m",
                text=self.tr(u'Ajustare bransamente la 1m'),
                callback=self.cut_bpmp,
                parent=self.iface.mainWindow(),
                icon_path= str(self.plugin_path('icons/cut.png')),
                enabled_flag=True
            ),
            self.add_action(
                "Completare câmpuri",
                text=self.tr(u'Completare câmpuri'),
                callback=self.complete_fields,
                parent=self.iface.mainWindow(),
                icon_path= str(self.plugin_path('icons/autocomplete.png')),
                enabled_flag=True
            ),
            self.add_action(
                "Verificare numerotare stâlpi",
                text=self.tr(u'Verificare numerotare stâlpi'),
                callback=self.verify_pole_numbering,
                parent=self.iface.mainWindow(),
                icon_path= str(self.plugin_path('icons/num.png')),
                enabled_flag=True
            ),
            self.add_action(
                "Verificare denumire străzi - STALP_JT, BRANS_FIRI_GRPM_JT",
                text=self.tr(u'Verificare denumire străzi - STALP_JT, BRANS_FIRI_GRPM_JT'),
                callback=self.verify_street_names,
                parent=self.iface.mainWindow(),
                icon_path= str(self.plugin_path('icons/street.png')),
                enabled_flag=True
            ),
            self.add_action(
                "Corespondență LINIA_JT - TRONSON_JT cu BRANS_FIRI_GRPM_JT",
                text=self.tr(u'Corespondență LINIA_JT - TRONSON_JT cu BRANS_FIRI_GRPM_JT'),
                callback=self.verify_linia_jt_matches,
                parent=self.iface.mainWindow(),
                icon_path= str(self.plugin_path('icons/mapping.png')),
                enabled_flag=True
            ),
            self.add_action(
                "Verificare coloane",
                text=self.tr(u'Verificare coloane'),
                callback=self.verify_mandatory_columns,
                parent=self.iface.mainWindow(),
                icon_path= str(self.plugin_path('icons/mandatory.png')),
                enabled_flag=True
            ),
            self.add_action(
                "Verificare circuit greșit",
                text=self.tr(u'Verificare circuit greșit'),
                callback=self.verify_circuit,
                parent=self.iface.mainWindow(),
                icon_path= str(self.plugin_path('icons/circuit.png')),
                enabled_flag=True
            ),
            self.add_action(
                "Verificare strazi si generare excel",
                text=self.tr(u'Verificare strazi si generare excel'),
                callback=self.verify_streets,
                parent=self.iface.mainWindow(),
                icon_path= str(self.plugin_path('icons/excel.png')),
                enabled_flag=False
            )
        ]
        
        self.action_length = self.add_action(
            "Lungime PT",
            text=self.tr(u"Lungime TRONSON_JT: 0.0 km")
        )

        QgsProject.instance().layersAdded.connect(self.onLayersAdded)
        QgsProject.instance().loadingLayer.connect(self.onProjectRead)

        layers = QgsProject.instance().mapLayersByName("TRONSON_JT")
        if layers:
            self.layer = layers[0]
            self.connectLayerSignals(self.layer)
            self.recalc_length()

        # will be set False in run()
        self.first_start = True

    def connectLayerSignals(self, layer):
        layer.featureAdded.connect(self.recalc_length)
        layer.featuresDeleted.connect(self.recalc_length)
        layer.geometryChanged.connect(self.recalc_length)
        layer.committedFeaturesAdded.connect(self.recalc_length)
        layer.committedFeaturesRemoved.connect(self.recalc_length)
        layer.committedGeometriesChanges.connect(self.recalc_length)
        layer.afterCommitChanges.connect(self.recalc_length)

    def onLayersAdded(self, layers):
        for layer in layers:
            if layer.name() == "TRONSON_JT":
                self.layer = layer
                self.connectLayerSignals(layer)
                self.recalc_length()

    def onProjectRead(self):
        layers = QgsProject.instance().mapLayersByName("TRONSON_JT")
        if layers:
            self.layer = layers[0]
            self.connectLayerSignals(self.layer)
            self.recalc_length()

    def recalc_length(self):
        """Recalculate the total length for TRONSON_JT, ignoring overlaps."""
        total_union = None

        for feat in self.layer.getFeatures():
            geom = feat.geometry()
            if not geom or geom.isEmpty():
                continue

            if total_union is None:
                total_union = geom
            else:
                total_union = total_union.combine(geom)

        total_length_km = 0.0
        if total_union:
            total_length_km = total_union.length() / 1000.0

        if self.action_length:
            self.action_length.setText(self.tr(u"Lungime TRONSON_JT: {:.2f} km".format(total_length_km)))

        QgsMessageLog.logMessage(f"Lungime TRONSON_JT: {total_length_km} km", "DesenAssist", Qgis.Info)


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(self.tr(u'&Desen Assist'), action)
            self.toolbar.removeAction(action)
        del self.toolbar
        
    def set_base_dir(self):
        project = QgsProject.instance()
        missing_layers = []
        layers = {}
        
        required_layers = ["BRANS_FIRI_GRPM_JT", "FB pe C LES", "TRONSON_JT", "STALP_JT", "LINIE_JT"]
        
        for layer_name in required_layers:
            found_layers = project.mapLayersByName(layer_name)
            if not found_layers:
                missing_layers.append(layer_name)
            else:
                layers[layer_name] = found_layers[0]
        
        if missing_layers:
            QMessageBox.critical(None, "Eroare", f"Urmatoarele straturi lipsesc: {', '.join(missing_layers)}. Asigură-te că straturile există în proiect și au denumirile corecte.")
            return

        self.layers = layers
        
        base_dir = QFileDialog.getExistingDirectory(None, "Selectați folder-ul de bază", "")
        if base_dir:
            self.base_dir = base_dir
            self.fisier_destinatie_action.setIcon(QIcon(str(self.plugin_path('icons/complete.png'))))
            for action in self.actions_to_enable:
                action.setEnabled(True)

        
    def get_layer_path(self, layer_name):
        """
        Get the full data source path of a layer by its name.

        Parameters:
            layer_name (str): The name of the layer in the QGIS project.

        Returns:
            str: The full data source path of the layer, including `|layername=`.
                Returns None if the layer is not found.
        """
        # Search for the layer by name in the current project
        layers = QgsProject.instance().mapLayersByName(layer_name)
        if not layers:
            return None
        
        # Get the first matching layer
        layer = layers[0]
        # Extract the data source path
        data_source = layer.dataProvider().dataSourceUri()
        
        # Append layername (important for GPKG files with multiple layers)
        if layer.storageType() == "GeoPackage" and "|layername=" not in data_source:
            data_source += f"|layername={layer.name()}"
        
        return data_source

    def clean_denum(self, denum):
        denum = str(denum)
        if denum:
            # Extract numeric and alphabetic parts
            match = re.match(r'(\d+)([A-Za-z]*)', denum)
            if match:
                numeric_part = int(match.group(1))  # Numeric part
                alpha_part = match.group(2).upper()  # Alphabetic part (uppercased)
                return (numeric_part, alpha_part)
        return (float('inf'), '')  # Non-matching cases go to the end

    # Process Layers
    def process_layers(self, layers):
        if not self.processor:
            try:
                self.processor = SHPProcessor(layers)
            except Exception as e:
                return
        
        try:
            current_layers = self.helper.get_layers()
        except Exception as e:
            return
        
        if current_layers != layers:
            self.processor = None
            
            try:
                self.processor = SHPProcessor(current_layers)
            except Exception as e:
                return
        else:
            return
        
    def create_scratch_layer(self, name, geom_type):
        crs = "EPSG:3844"
        if geom_type == "Point":
            uri = f"Point?crs={crs}"
        elif geom_type == "LineString":
            uri = f"LineString?crs={crs}"
        else:
            uri = f"None?crs={crs}"

        layer = QgsVectorLayer(uri, name, "memory")
        provider = layer.dataProvider()

        fields = QgsFields()
        fields.append(QgsField("nume_layer", QVariant.String))  
        fields.append(QgsField("coloane", QVariant.String))     
        fields.append(QgsField("feature_id", QVariant.Int))
        provider.addAttributes(fields)
        layer.updateFields()
        return layer

    def prepare_and_separate(self):
        success = self.assign_id_bdis(self.layers)
        
        if success:
            self.separate_poles_by_id(self.layers)
        else:
            QMessageBox.critical(None, "Eroare", "Eroare la asignarea ID_BDI")
    
    def assign_id_bdis(self, layers):
        """
        Completes ID_BDI for BRANS_FIRI_GRPM_JT, FB_pe_C_LES, TRONSON_JT by mapping from their LINIE_JT - which corresponds to DENUM from layer LINIA_JT (which also has ID_BDI)
        Completes ID_BDI for STALP_JT by getting the intersected TRONSON_JT's ID_BDI. If multiple intersecting TRONSON_JT features have different ID_BDI values, assign the most frequent one.
        If no intersection is found in TRONSON_JT, checks for intersections in BRANS_FIRI_GRPM_JT.
        """
        
        # Create dictionary for LINIE_JT mapping (DENUM -> ID_BDI)
        linia_jt_layer = layers["LINIE_JT"]
        linia_jt_mapping = {feat["DENUM"]: feat["ID_BDI"] for feat in linia_jt_layer.getFeatures()}
        
        # Update ID_BDI for BRANS_FIRI_GRPM_JT, FB pe C LES, TRONSON_JT based on LINIA_JT
        for layer_name in ["BRANS_FIRI_GRPM_JT", "FB pe C LES", "TRONSON_JT"]:
            layer = layers[layer_name]
            layer.startEditing()
            for feature in layer.getFeatures():
                linia_denum = feature["LINIA_JT"]
                if linia_denum in linia_jt_mapping:
                    feature["ID_BDI"] = linia_jt_mapping[linia_denum]
                    layer.updateFeature(feature)
            layer.commitChanges()
        
        # Spatially join ID_BDI from TRONSON_JT to STALP_JT
        tronson_jt_layer = layers["TRONSON_JT"]
        bransament_jt_layer = layers["BRANS_FIRI_GRPM_JT"]
        stalp_jt_layer = layers["STALP_JT"]
        
        spatial_index_tr = QgsSpatialIndex(tronson_jt_layer.getFeatures())
        spatial_index_br = QgsSpatialIndex(bransament_jt_layer.getFeatures())
        
        stalp_jt_layer.startEditing()
        for stalp in stalp_jt_layer.getFeatures():
            intersecting_ids_tr = spatial_index_tr.intersects(stalp.geometry().boundingBox())
            
            id_bdi_value = None  # Store found ID_BDI
            
            # First, try to get ID_BDI from intersecting TRONSON_JT
            if intersecting_ids_tr:
                for tronson in tronson_jt_layer.getFeatures(QgsFeatureRequest().setFilterFids(intersecting_ids_tr)):
                    if stalp.geometry().intersects(tronson.geometry()):
                        id_bdi_value = tronson["ID_BDI"]
                        if id_bdi_value:  # If found, no need to check further
                            break
            
            # If no ID_BDI found in TRONSON_JT, check BRANS_FIRI_GRPM_JT
            if not id_bdi_value:
                intersecting_ids_br = spatial_index_br.intersects(stalp.geometry().boundingBox())
                
                if intersecting_ids_br:
                    for bransament in bransament_jt_layer.getFeatures(QgsFeatureRequest().setFilterFids(intersecting_ids_br)):
                        if stalp.geometry().intersects(bransament.geometry()):
                            id_bdi_value = bransament["ID_BDI"]
                            if id_bdi_value:
                                break  # Stop as soon as one is found
            
            # Assign the found ID_BDI to the STALP_JT feature
            if id_bdi_value:
                stalp["ID_BDI"] = id_bdi_value
                stalp_jt_layer.updateFeature(stalp)

        stalp_jt_layer.commitChanges()
        return True


    def separate_poles_by_id(self, layers):
        """
        Filters all layers based on user-input ID_BDI values and exports them into single .gpkg files per layer type.
        """
        id_bdis, ok = QInputDialog.getText(None, "Input ID_BDI", "ID_BDI:")

        if ok and not id_bdis:
            QMessageBox.warning(None, "Input Error", "ID_BDI nu a fost introdus.")
            return

        if id_bdis:
            # Convert input IDs to a list
            id_bdi_list = [id_bdi.strip() for id_bdi in id_bdis.split(",") if id_bdi.strip()]
            
            # Access the layers
            linie_jt_layer = layers["LINIE_JT"]
            stalp_jt_layer = layers["STALP_JT"]
            brans_layer = layers["BRANS_FIRI_GRPM_JT"]
            fb_les_layer = layers["FB pe C LES"]
            tronson_layer = layers["TRONSON_JT"]
            
            # Define layers to filter
            layers_to_filter = {
                "LINIE_JT": linie_jt_layer,
                "STALP_JT": stalp_jt_layer,
                "BRANS_FIRI_GRPM_JT": brans_layer,
                "FB pe C LES": fb_les_layer,
                "TRONSON_JT": tronson_layer
            }
            
            base_dir = self.base_dir
            if not os.path.exists(base_dir):
                os.makedirs(base_dir)
            
            # Create a new group in QGIS
            root = QgsProject.instance().layerTreeRoot()
            new_group = root.addGroup(f"Date_Filtrate_{'_'.join(id_bdi_list)}")
            
            missing_id_bdis = []
            
            for id_bdi in id_bdi_list:
                found = False
                for feature in linie_jt_layer.getFeatures():
                    if str(feature["ID_BDI"]) == id_bdi:
                        found = True
                        break
                if not found:
                    missing_id_bdis.append(id_bdi)
            
            for layer_name, original_layer in layers_to_filter.items():
                # Retrieve geometry type and CRS
                geometry_type = QgsWkbTypes.displayString(original_layer.wkbType())
                crs = original_layer.crs().authid()
                
                # Create a new in-memory layer
                new_layer = QgsVectorLayer(f"{geometry_type}?crs={crs}", layer_name, "memory")
                new_layer_data = new_layer.dataProvider()
                new_layer_data.addAttributes(original_layer.fields())
                new_layer.updateFields()
                
                # Collect all matching features
                matching_features = []
                for feature in original_layer.getFeatures():
                    if str(feature["ID_BDI"]) in id_bdi_list:
                        matching_features.append(QgsFeature(feature))
                
                # Add filtered features to new layer (even if empty)
                new_layer_data.addFeatures(matching_features)
                new_layer.updateExtents()
                
                # Export to GeoPackage
                output_path = os.path.join(base_dir, f"{layer_name}.gpkg")
                QgsVectorFileWriter.writeAsVectorFormat(
                    new_layer, output_path, "UTF-8", original_layer.crs(), "GPKG"
                )
                
                # Add to QGIS and group
                QgsProject.instance().addMapLayer(new_layer, False)
                new_group.addLayer(new_layer)
            
            QMessageBox.information(None, "Success", "Layerele filtrate au fost salvate cu succes")
            
            if missing_id_bdis:
                QMessageBox.warning(None, "ID_BDI lipsă în LINIE_JT", f"ID_BDI lipsă în LINIE_JT: {', '.join(missing_id_bdis)}")

    def complete_fields(self):
        '''
        STALP_JT
        > if NR_CIR_FO is completed, PROP_FO = SC RCS&RDS S.A
        > UZURA_STP = 5 if field is in config.NULL_VALUES
        '''
        self.update_branch_fields()
        self.update_prop_column()
        self.update_tip_fund()
        self.verify_true_false_columns()
        self.update_uzu_stp_prop_fo()
        
        QMessageBox.information(None, "Completare campuri", "Campurile au fost completate cu succes.")

    def cut_bpmp(self):
        # Retrieve the layers
        br_layers = QgsProject.instance().mapLayersByName("BRANS_FIRI_GRPM_JT")
        
        if not br_layers:
            QMessageBox.warning(None, "Eroare", "Stratul BRANS_FIRI_GRPM_JT nu a fost găsit.")
            return

        br_layer = br_layers[0]

        # Define field names to check
        br_field = "TIP_FIRI_BR"
        cond_field = "TIP_COND"

        # Start an edit session on the br_layer if not already in one
        if not br_layer.isEditable():
            br_layer.startEditing()

        # Iterate through each feature
        for feat in br_layer.getFeatures():
            # Apply condition: check if the field value is BMPM or BMPT
            # and that TIP_COND is not 'ACYABY 4x16'
            if feat[br_field] in ("BMPM", "BMPT", "FDCS", "FDCP") and feat[cond_field] not in ["ACYABY 4X16", "ACYABY 4x16"]:
                geom = feat.geometry()
                # Ensure we are dealing with a simple polyline (skip multipart for now)
                if geom.isMultipart():
                    continue

                points = geom.asPolyline()
                # Require at least two vertices to define a segment
                if len(points) < 2:
                    continue

                # Identify the last segment endpoints
                p_second_last = points[-2]
                p_last = points[-1]

                # Compute the current segment length
                current_length = p_second_last.distance(p_last)
                # Avoid division by zero
                if current_length == 0:
                    continue

                # Compute the normalized direction vector from the second-last to the last vertex
                dx = p_last.x() - p_second_last.x()
                dy = p_last.y() - p_second_last.y()
                norm = (dx**2 + dy**2)**0.5
                ndx = dx / norm
                ndy = dy / norm

                # The new last vertex is positioned 1 meter from the second-last vertex,
                # regardless of whether that means shortening or extending the segment.
                new_last = QgsPointXY(p_second_last.x() + ndx * 1.0,
                                    p_second_last.y() + ndy * 1.0)
                points[-1] = new_last

                # Reconstruct the geometry with the adjusted vertex
                new_geom = QgsGeometry.fromPolylineXY(points)
                # Update the feature's geometry in the layer
                br_layer.changeGeometry(feat.id(), new_geom)

        # Commit all changes made during the edit session
        br_layer.commitChanges()
        QMessageBox.information(None, "Success", "Bransamentele BMPM, BMPT, FDCS și FDCP (cu exceptia celor cu TIP_COND = ACYABY 4x16) au fost ajustate la 1 metru.")


# A.	Verificare numerotare stalpi
    def verify_pole_numbering(self):
        self.verify_br()
        self.verify_jt()
    
    def verify_jt(self):
        # Step 1: Get the original layer
        original_layers = QgsProject.instance().mapLayersByName("STALP_JT")
        
        if not original_layers:
            QMessageBox.warning(None, "Eroare", "Stratul STALP_JT nu a fost găsit.")
            return
        
        original_layer = original_layers[0]

        # Step 2: Filter features with "JT" in the "TIP_CIR" field
        jt_features = sorted(
            [f for f in original_layer.getFeatures() if "JT" in f["TIP_CIR"]],
            key=lambda f: int(f["DENUM"])
        )

        # Step 3: Create a new scratch layer
        scratch_layer = QgsVectorLayer(
            "Point?crs=" + original_layer.crs().toWkt(), 
            "Verificare_Numerotare_Stalpi_JT", 
            "memory"
        )
        scratch_layer_data = scratch_layer.dataProvider()

        # Add only the necessary fields
        fields = QgsFields()
        fields.append(QgsField("fid", QVariant.Int))
        fields.append(QgsField("TIP_CIR", QVariant.String))
        fields.append(QgsField("ID_PROVIZ", QVariant.Int))
        fields.append(QgsField("DENUM", QVariant.String))
        fields.append(QgsField("MATCH_STATUS", QVariant.String))
        scratch_layer_data.addAttributes(fields)
        scratch_layer.updateFields()

        for idx, feature in enumerate(jt_features, start=1):
            idx = idx - 1
            
            new_feature = QgsFeature()
            new_feature.setGeometry(feature.geometry())
            new_feature.setFields(scratch_layer.fields())

            new_feature["fid"] = feature.id()
            new_feature["TIP_CIR"] = feature["TIP_CIR"]
            new_feature["ID_PROVIZ"] = idx
            new_feature["DENUM"] = feature["DENUM"]
            new_feature["MATCH_STATUS"] = "Da" if idx == int(feature["DENUM"]) else "Nu"
            
            QgsMessageLog.logMessage(f"Feature {feature.id()} - idx {idx} with {feature['DENUM']} - {new_feature['MATCH_STATUS']}", "DesenAssist", Qgis.Info)

            scratch_layer_data.addFeature(new_feature)


        # Add the scratch layer to the project
        QgsProject.instance().addMapLayer(scratch_layer)

    def verify_br(self):
        original_layers = QgsProject.instance().mapLayersByName("STALP_JT")
        
        if not original_layers:
            QMessageBox.warning(None, "Eroare", "Stratul STALP_JT nu a fost găsit.")
            return
        
        original_layer = original_layers[0]

        # Uppercase the DENUM field in the original layer and save changes
        original_layer.startEditing()
        for feature in original_layer.getFeatures():
            denum = feature["DENUM"]
            if denum:
                feature["DENUM"] = denum.upper()
                original_layer.updateFeature(feature)
        original_layer.commitChanges()

        jt_features = [f for f in original_layer.getFeatures() if "BR" in f["TIP_CIR"] and "JT" not in f["TIP_CIR"]]
        jt_features_sorted = sorted(jt_features, key=lambda f: self.clean_denum(f["DENUM"]))

        # Create a new scratch layer for BR features
        scratch_layer = QgsVectorLayer(
            "Point?crs=" + original_layer.crs().toWkt(),
            "Verificare_Numerotare_Stalpi_Auxiliari",
            "memory"
        )
        scratch_layer_data = scratch_layer.dataProvider()

        # Add only the necessary fields
        fields = QgsFields()
        fields.append(QgsField("fid", QVariant.Int))  # Original feature ID
        fields.append(QgsField("TIP_CIR", QVariant.String))
        fields.append(QgsField("DENUM", QVariant.String))
        scratch_layer_data.addAttributes(fields)
        scratch_layer.updateFields()

        # Populate the new layer with sorted features and compute new fields
        for idx, feature in enumerate(jt_features_sorted):  # Enumerate in the sorted DENUM order
            new_feature = QgsFeature()
            new_feature.setGeometry(feature.geometry())
            new_feature.setFields(scratch_layer.fields())

            # Add new fields
            new_feature["fid"] = feature.id()
            new_feature["TIP_CIR"] = feature["TIP_CIR"]
            new_feature["DENUM"] = feature["DENUM"]

            # Add feature to the scratch layer
            scratch_layer_data.addFeature(new_feature)

        # Add the scratch layer to the project
        QgsProject.instance().addMapLayer(scratch_layer)


# C.	Coloana “linie jt” sa fie la fel la bransament si la tronson - WORKING
    def verify_linia_jt_matches(self):
        '''
        Checks for mismatched LINIA_JT values between intersecting features
        in BRANS_FIRI_GRPM_JT and TRONSON_JT layers.
        For every BRANS feature, each intersecting TRONSON feature is examined.
        If the LINIA_JT values differ, a record is added to a scratch layer.
        The scratch layer contains three fields:
        "fid" - the BRANS feature ID,
        "TRONSON_JT_LINIA_JT" - the LINIA_JT value from the TRONSON feature,
        "BRANSAMENT_LINIA_JT" - the LINIA_JT value from the BRANS feature.
        '''
        # Load layers
        brans_layers = QgsProject.instance().mapLayersByName('BRANS_FIRI_GRPM_JT')
        tronson_layers = QgsProject.instance().mapLayersByName('TRONSON_JT')
        
        missing_layers = []
        if not brans_layers:
            missing_layers.append('BRANS_FIRI_GRPM_JT')
        if not tronson_layers:
            missing_layers.append('TRONSON_JT')
        if missing_layers:
            QMessageBox.critical(None, "Eroare", f"Urmatoarele straturi lipsesc: {', '.join(missing_layers)}. Asigură-te că straturile există în proiect și au denumirile corecte.")
            return
        
        brans_layer = brans_layers[0]
        tronson_layer = tronson_layers[0]
        
        # Build a spatial index for TRONSON layer for efficient querying.
        tronson_index = QgsSpatialIndex(tronson_layer.getFeatures())
        
        mismatches = []
        
        # Iterate over each BRANS feature.
        for brans_feature in brans_layer.getFeatures():
            brans_linia = brans_feature["LINIA_JT"]
            if not brans_linia:
                continue
            brans_geom = brans_feature.geometry()
            
            # Find candidate TRONSON features that intersect the BRANS feature’s bounding box.
            candidate_ids = tronson_index.intersects(brans_geom.boundingBox())
            for cand_id in candidate_ids:
                tronson_feature = tronson_layer.getFeature(cand_id)
                if brans_geom.intersects(tronson_feature.geometry()):
                    tronson_linia = tronson_feature["LINIA_JT"]
                    # If the LINIA_JT values differ, record this mismatch.
                    if tronson_linia != brans_linia:
                        new_feature = QgsFeature()
                        new_feature.setGeometry(brans_geom)
                        new_feature.setAttributes([str(brans_feature.id()), tronson_linia, brans_linia])
                        mismatches.append(new_feature)
        
        if mismatches:
            scratch_layer = QgsVectorLayer("LineString?crs=EPSG:3844", "LINIA_JT_verificare", "memory")
            fields = QgsFields()
            fields.append(QgsField("fid", QVariant.String))
            fields.append(QgsField("TRONSON_JT_LINIA_JT", QVariant.String))
            fields.append(QgsField("BRANSAMENT_LINIA_JT", QVariant.String))
            scratch_layer.dataProvider().addAttributes(fields)
            scratch_layer.updateFields()
            
            scratch_layer.dataProvider().addFeatures(mismatches)
            scratch_layer.commitChanges()
            QgsProject.instance().addMapLayer(scratch_layer)
            
            QMessageBox.information(None, "LINIA_JT", 
                "Au fost gasite linii JT cu valori diferite intre BRANS_FIRI_GRPM_JT si TRONSON_JT.")
        else:
            QMessageBox.information(None, "LINIA_JT", 
                "Toate campurile de LINIA_JT corespund intre BRANS_FIRI_GRPM_JT si TRONSON_JT.")

        
    def verify_street_names(self):
        self.verify_street_names_poles()
        self.verify_street_brans()
        
        QMessageBox.information(None, "STR", 
            "Denumirile străzilor pentru bransamente și stâlpi au fost verificate cu succes. Verifică straturile adăugate pentru detalii.")


    def verify_street_brans(self):
        brans_layer_name = "BRANS_FIRI_GRPM_JT"
        stalp_layer_name = "STALP_JT"

        brans_layer = QgsProject.instance().mapLayersByName(brans_layer_name)
        stalp_layer = QgsProject.instance().mapLayersByName(stalp_layer_name)

        missing_layers = []
        if not brans_layer:
            missing_layers.append(brans_layer_name)
        if not stalp_layer:
            missing_layers.append(stalp_layer_name)
            
        if missing_layers:
            QMessageBox.critical(None, "Eroare", f"Urmatoarele straturi lipsesc: {', '.join(missing_layers)}. Asigură-te că straturile există în proiect și au denumirile corecte.")
            return

        brans_layer = brans_layer[0]
        stalp_layer = stalp_layer[0]

        context = QgsProcessingContext()

        params = {
            'INPUT': brans_layer,
            'JOIN': stalp_layer,
            'PREDICATE': [0],  # Intersects
            'JOIN_FIELDS': ['STR'],  # Join the STR field from the stalp layer
            'METHOD': 0,  # Create temporary layer
            'DISCARD_NONMATCHING': False,
            'OUTPUT': 'memory:'  # Output to memory
        }

        try:
            join_output = processing.run("native:joinattributesbylocation", params, context=context)
            joined_layer = join_output['OUTPUT']

            uri = f"LineString?crs={brans_layer.crs().authid()}"
            non_match_layer = QgsVectorLayer(uri, "Validare_denumiri_strazi_bransamente", "memory")
            non_match_dp = non_match_layer.dataProvider()
            non_match_dp.addAttributes([
                QgsField("BRANSAMENT_fid", QVariant.Int),
                QgsField("BRANSAMENT_STR", QVariant.String),
                QgsField("STALP_STR", QVariant.String)
            ])
            non_match_layer.updateFields()

            diff_features = []
            for feature in joined_layer.getFeatures():
                brans_street = feature['STR']
                stalp_street = feature['STR_2']
                if brans_street != stalp_street:
                    new_feature = QgsFeature(non_match_layer.fields())
                    new_feature.setAttribute("BRANSAMENT_fid", feature.id())
                    new_feature.setAttribute("BRANSAMENT_STR", brans_street)
                    new_feature.setAttribute("STALP_STR", stalp_street)
                    new_feature.setGeometry(feature.geometry())
                    diff_features.append(new_feature)

            non_match_dp.addFeatures(diff_features)
            non_match_layer.updateExtents()

            QgsProject.instance().addMapLayer(non_match_layer)

        except Exception as e:
            QgsMessageLog.logMessage(f"An error occurred: {e}", 'DesenAssist', Qgis.Critical)
            return


    def verify_street_names_poles(self):
        def normalize_text(text):
            replacements = {
                'ă': 'a', 'â': 'a', 'î': 'i', 'ș': 's', 'ş': 's', 'ț': 't', 'ţ': 't',
                'Ă': 'A', 'Â': 'A', 'Î': 'I', 'Ș': 'S', 'Ş': 'S', 'Ț': 'T', 'Ţ': 'T'
            }
            for diacritic, replacement in replacements.items():
                text = text.replace(diacritic, replacement)
            return text
        
        missing_layers = []
        orig_layer = QgsProject.instance().mapLayersByName('STALP_JT')
        nr_postale_layer = QgsProject.instance().mapLayersByName('nr_postale')
        
        if not orig_layer:
            missing_layers.append('STALP_JT')
        if not nr_postale_layer:
            missing_layers.append('nr_postale')
            
        if missing_layers:
            QMessageBox.critical(None, "Eroare", f"Urmatoarele straturi lipsesc: {', '.join(missing_layers)}. Asigură-te că straturile există în proiect și au denumirile corecte.")
            return
        
        nr_postale_layer = nr_postale_layer[0]
        orig_layer = orig_layer[0]

        memory_layer = QgsVectorLayer("Point?crs=EPSG:3844", "STALP_JT_verificare_denum", "memory")
        dp = memory_layer.dataProvider()
        
        new_fields = QgsFields()
        new_fields.append(QgsField("fid", QVariant.Int))
        new_fields.append(QgsField("STR", QVariant.String))
        dp.addAttributes(new_fields)
        memory_layer.updateFields()

        denumire_d_values = set()
        for feature in nr_postale_layer.getFeatures():
            denumire_d = feature['DENUMIRE_D']
            if denumire_d:
                denumire_d_values.add(normalize_text(denumire_d))

        memory_layer.startEditing()
        for feature in orig_layer.getFeatures():
            str_value = feature['STR']
            if str_value:
                norm_str = normalize_text(str_value)
                if norm_str not in denumire_d_values:
                    new_feat = QgsFeature()
                    new_feat.setGeometry(feature.geometry())
                    new_feat.setFields(new_fields)
                    new_feat['fid'] = feature.id()
                    new_feat['STR'] = norm_str
                    dp.addFeatures([new_feat])
        memory_layer.commitChanges()

        QgsProject.instance().addMapLayer(memory_layer)
        QgsProject.instance().write()

    def verify_mandatory_columns(self):
        self.verify_num_columns()
        layers_to_check = {
            "STALP_JT": [
                "DENUM", "NR_INS_STP", "PROP", "JUD", "PRIM", "LOC", "TIP_STR", "STR", 
                "TIP_CIR", "DESC_CTG_MT_JT", "NR_CIR", "UZURA_STP", "TIP_FUND", 
                "ADAOS", "TIP_LEG_JT", "fid"],
            "BRANS_FIRI_GRPM_JT": [
                "fid", "TIP_BR", "TIP_COND", "JUD", "PRIM", "LOC", "TIP_STR", "STR", 
                "NR_IMOB", "TIP_FIRI_BR", "LINIA_JT"],
            "TRONSON_JT": [
                "TIP_TR", "TIP_COND", "fid", "LINIA_JT"],
            "FB pe C LES": [
                "fid", "DENUM", "TIP_BR", "TIP_COND", "JUD", "PRIM", "LOC", "TIP_STR", 
                "STR", "NR_IMOB", "SURSA_COORD", "DATA_COORD", "TIP_FIRI_BR", "LINIA_JT"],
            "LINIE_JT": [
                "ID_BDI", "DENUM"]
        }

        layer_types = {
            "STALP_JT": "Point",
            "FB pe C LES": "Point",
            "TRONSON_JT": "LineString",
            "BRANS_FIRI_GRPM_JT": "LineString",
            "LINIE_JT": "None"
        }

        created_layers = {}
        
        mistake = False

        for layer_name, columns in layers_to_check.items():
            layers = QgsProject.instance().mapLayersByName(layer_name.strip())
            if not layers:
                continue

            layer = layers[0]
            geom_type = layer_types[layer_name]

            scratch_layer = None
            for feature in layer.getFeatures():
                if layer_name == "STALP_JT":
                    incomplete_columns = set()
                    nr_cir_fo_val = feature['NR_CIR_FO']
                    prop_fo_val = feature['PROP_FO']
                    
                    if nr_cir_fo_val not in config.NULL_VALUES and prop_fo_val in config.NULL_VALUES:
                        incomplete_columns.add('PROP_FO (NR_CIR_FO e completat)')
                                
                    for column in columns:
                        if column not in [field.name() for field in layer.fields()]:
                            continue
                        value = feature[column]
                        if value in config.NULL_VALUES:
                            incomplete_columns.add(column)
                        
                if incomplete_columns:
                    mistake = True
                    if not scratch_layer:
                        scratch_layer = self.create_scratch_layer(f"{layer_name}_coloane_necompletate", geom_type)
                        created_layers[layer_name] = scratch_layer

                    new_feature = QgsFeature(scratch_layer.fields())
                    new_feature.setAttributes([
                        layer_name,                         
                        ", ".join(incomplete_columns),     
                        feature.id()                            
                    ])
                    if geom_type != "None":
                        geometry = feature.geometry()
                        if geometry and geometry.isGeosValid():
                            new_feature.setGeometry(geometry)
                            
                    scratch_layer.dataProvider().addFeature(new_feature)
            
        if mistake:
            group = QgsProject.instance().layerTreeRoot().addGroup("Coloane necompletate")
            for _, layer in created_layers.items():
                QgsProject.instance().addMapLayer(layer, False)
                group.addLayer(layer)
            
            QMessageBox.warning(None, "Coloane necompletate", "Unele coloane obligatorii nu sunt completate. Verifică layerele rezultate.")
        else:
            QMessageBox.information(None, "Coloane completate", "Toate coloanele obligatorii sunt completate.")

    def verify_circuit(self):
        tronson_layer_name = "TRONSON_JT"

        tronson_layer = QgsProject.instance().mapLayersByName(tronson_layer_name)

        if not tronson_layer:
            return

        tronson_layer = tronson_layer[0]

        dissolve_params = {
            'INPUT': tronson_layer,
            'FIELD': ['LINIA_JT'],
            'OUTPUT': 'memory:',
        }
        dissolved_layer = processing.run("native:dissolve", dissolve_params)['OUTPUT']

        buffer_params = {
            'INPUT': dissolved_layer,
            'DISTANCE': 0.001,
            'SEGMENTS': 5,
            'END_CAP_STYLE': 0,
            'JOIN_STYLE': 0,
            'MITER_LIMIT': 2,
            'DISSOLVE': False,
            'OUTPUT': 'memory:',
        }
        buffered_layer = processing.run("native:buffer", buffer_params)['OUTPUT']

        singlepart_params = {
            'INPUT': buffered_layer,
            'OUTPUT': 'memory:',
        }
        singlepart_layer = processing.run("native:multiparttosingleparts", singlepart_params)['OUTPUT']

        singlepart_layer.setName("Verificare_circuite")

        QgsProject.instance().addMapLayer(singlepart_layer)
                
    def apply_categorization(self, layer, field_name):
            unique_values = layer.uniqueValues(layer.fields().lookupField(field_name))
            categories = []
            
            predefined_colors = [
                QColor(255, 0, 0), QColor(0, 255, 0), QColor(0, 0, 255),
                QColor(255, 255, 0), QColor(255, 165, 0), QColor(255, 20, 147),
                QColor(0, 255, 255), QColor(128, 0, 128), QColor(0, 128, 0),
                QColor(0, 0, 128), QColor(75, 0, 130), QColor(255, 105, 180)
            ]
            random.shuffle(predefined_colors)
            
            for i, value in enumerate(unique_values):
                if i >= len(predefined_colors):
                    break
                symbol = QgsSymbol.defaultSymbol(layer.geometryType())
                symbol.setColor(predefined_colors[i])
                symbol.setWidth(1.25)
                categories.append(QgsRendererCategory(value, symbol, str(value)))
            
            renderer = QgsCategorizedSymbolRenderer(field_name, categories)
            layer.setRenderer(renderer)
            layer.triggerRepaint()
        

    def verify_num_columns(self):
        layers_to_check = {
            "STALP_JT": [
                "UZURA_STP", "NR_CIR_FO", "NR_CIR_LTC", "NR_CIR_CATV", "NR_CONS_C2S", "NR_CONS_C4S", "NR_CONS_C2T", "NR_CONS_C4T", "NR_CONS_C2BR", "NR_CONS_C4BR"]
        }

        layer_types = {
            "STALP_JT": "Point",
        }

        created_layers = {}
        mistake = False

        for layer_name, columns in layers_to_check.items():
            layers = QgsProject.instance().mapLayersByName(layer_name.strip())
            if not layers:
                continue

            layer = layers[0]
            geom_type = layer_types[layer_name]

            scratch_layer = None
            for feature in layer.getFeatures():
                incorrect_column = set()
                for column in columns:
                    if column not in [field.name() for field in layer.fields()]:
                        continue
                    value = feature[column]
                    if value not in config.NULL_VALUES:
                        try:
                            value = int(str(value))
                        except ValueError:
                            incorrect_column.add(column)

                if incorrect_column:
                    mistake = True
                    if not scratch_layer:
                        scratch_layer = self.create_scratch_layer(f"{layer_name}_coloane_gresite_nr", geom_type)
                        created_layers[layer_name] = scratch_layer

                    new_feature = QgsFeature(scratch_layer.fields())
                    new_feature.setAttributes([
                        layer_name,                         
                        ", ".join(incorrect_column),     
                        feature.id()                            
                    ])
                    if geom_type != "None":
                        geometry = feature.geometry()
                        if geometry and geometry.isGeosValid():
                            new_feature.setGeometry(geometry)
                            
                    scratch_layer.dataProvider().addFeature(new_feature)
        for _, layer in created_layers.items():
            QgsProject.instance().addMapLayer(layer)
            
        if mistake:
            QMessageBox.information(None, "STALP_JT", "Unele coloane specificate conțin litere în loc de valori strict numerice. Verifică layerul rezultat.")
        else:
            QMessageBox.information(None, "STALP_JT", "Toate coloanele specificate [UZURA_STP, NR_CIR_FO, NR_CIR_LTC, NR_CIR_CATV, NR_CONS_C2S, NR_CONS_C4S, NR_CONS_C2T, NR_CONS_C4T, NR_CONS_C2BR, NR_CONS_C4BR] conțin doar valori numerice.")

            
    def verify_true_false_columns(self):
        columns_to_check = {
            "NR_CIR_FO": "FIB_OPT",
            "NR_CIR_LTC": "LTC",
            "NR_CIR_CATV": "CATV",
        }

        layers = QgsProject.instance().mapLayersByName("STALP_JT")
        
        if not layers:
            QMessageBox.warning(None, "Eroare", "Stratul STALP_JT nu a fost găsit.")
            return
        
        layer = layers[0]

        if not layer.isEditable():
            layer.startEditing()

        field_names = [field.name() for field in layer.fields()]

        for feature in layer.getFeatures():
            for key_field, bool_field in columns_to_check.items():
                if key_field not in field_names or bool_field not in field_names:
                    continue

                key_value = feature[key_field]
                is_completed = key_value not in config.NULL_VALUES

                new_value = "Da" if is_completed else "Nu"

                if feature[bool_field] != new_value:
                    field_index = layer.fields().indexFromName(bool_field)
                    layer.changeAttributeValue(feature.id(), field_index, new_value)

        if not layer.commitChanges():
            QMessageBox.critical(None, "FIB_OPT, LTC, CATV - STALP_JT", "Eroare la actualizarea coloanelor FIB_OPT, LTC, CATV.")
        
    def update_prop_column(self):
        """
        Updates the PROP field in the 'STALP_JT' layer based on the DESC_CTG_MT_JT field.
        If DESC_CTG_MT_JT is in the terti_codes list, PROP is set to 'TERTI';
        if it's in the electrica_codes list, PROP is set to 'ELECTRICA'.
        """
        layers = QgsProject.instance().mapLayersByName('STALP_JT')
        if not layers:
            QgsMessageLog.logMessage("Layer 'STALP_JT' not found.", 'DesenAssist', Qgis.Critical)
            return
        layer = layers[0]

        if not layer.isEditable():
            layer.startEditing()

        terti_codes = [
            'St. lemn tip SU', 'St. lemn tip SG', 'St. metalic rotund',
            'St. octogonal zincat sustinere', 'St. octogonal zincat intindere'
        ]
        electrica_codes = [
            'S 8 - U', 'S 9 - U', 'S 10 - U', 'S 10 - M', 'S 12 - M', 'S 10 - G',
            'S 11 - G', 'S 12 - G', 'S 13 - G', 'S 14 - G', 'SE 1A', 'SE 2', 'SE 3',
            'SE 4', 'SE 5', 'SE 6', 'SE 7', 'SE 8', 'SE 9', 'SE 10', 'SE 11',
            'SC 10001', 'SC 10002', 'SC 10005', 'SC 15004', 'SC 15006', 'SC 15007',
            'SC 15014-10.5', 'SC 15014', 'SI 9', 'SV 10001', 'SV 10002'
        ]

        for feature in layer.getFeatures():
            desc_value = feature['DESC_CTG_MT_JT']
            expected_prop = None

            if desc_value in terti_codes:
                expected_prop = 'TERTI'
            elif desc_value in electrica_codes:
                expected_prop = 'ELECTRICA'
            else:
                # If the description is not in any known list, skip updating.
                continue

            if feature['PROP'] not in [expected_prop, "TERTI + ELECTRICA(comodat)"]:
                feature['PROP'] = expected_prop
                layer.updateFeature(feature)

        if not layer.commitChanges():
            QMessageBox.critical(None, "PROP - STALP_JT", "Eroare la actualizarea coloanei PROP.")
        
    def update_tip_fund(self):
        layers = QgsProject.instance().mapLayersByName('STALP_JT')
        if not layers:
            QgsMessageLog.logMessage("Layer 'STALP_JT' not found.", 'DesenAssist', Qgis.Critical)
            return
        layer = layers[0]

        if not layer.isEditable():
            layer.startEditing()

        turnata_codes = ["St. lemn tip SU", "Portal", "St. lemn tip SG", "SC 10001", "SC 10002", "SC 10005", "SC 15004", "SC 15006", "SC 15007", "SC 15014-10.5", "SC 15014", "St. metalic rotund", "SE 1A", "SV 10001", "SV 10002", "SE 8", "SE 9", "SE 10", "SE 11"]

        for feature in layer.getFeatures():
            desc_ctg_mt_jt = feature["DESC_CTG_MT_JT"]
            
            if desc_ctg_mt_jt:
                if desc_ctg_mt_jt in turnata_codes:
                    layer.changeAttributeValue(feature.id(), layer.fields().indexFromName("TIP_FUND"), "Turnata")
                else:
                    layer.changeAttributeValue(feature.id(), layer.fields().indexFromName("TIP_FUND"), "Burata")

        if not layer.commitChanges():
            QMessageBox.critical(None, "TIP_FUND - STALP_JT", "Eroare la actualizarea coloanei TIP_FUND.")
        

    def update_branch_fields(self):
        """
        Updates the TIP_BR field in the 'BRANS_FIRI_GRPM_JT' layer based on the code in TIP_FIRI_BR.
        For codes 'FB1', 'FM1', 'BMPM', TIP_BR is set to 'monofazat'.
        For codes 'FB3', 'FM3', 'BMPT', TIP_BR is set to 'trifazat'.
        """
        code_to_branch = {
            "FB1": "monofazat",
            "FM1": "monofazat",
            "BMPM": "monofazat",
            "FB3": "trifazat",
            "FM3": "trifazat",
            "BMPT": "trifazat",
        }
        
        layer_list = QgsProject.instance().mapLayersByName("BRANS_FIRI_GRPM_JT")
        if not layer_list:
            QgsMessageLog.logMessage("Layer 'BRANS_FIRI_GRPM_JT' not found.", "DesenAssist", Qgis.Critical)
            return
        layer = layer_list[0]
        
        if not layer.isEditable():
            layer.startEditing()
            
        vague = False
        
        for feature in layer.getFeatures():
            code = feature["TIP_FIRI_BR"]
            tip_cond = feature["TIP_COND"]
            
            fdcs_tip_cond_trifazat = ["TYIR 3X25Al + 16Al", "AFYI 4X16", "AFYI 4x16"]
            fdcp_tip_cond_trifazat = ["TYIR 3X25Al + 16Al", "ACBYCY 16/16"]
            
            if code in code_to_branch:
                branch_value = code_to_branch[code]
            elif tip_cond in fdcs_tip_cond_trifazat and code == "FDCS":
                branch_value = "trifazat"
            elif tip_cond in fdcp_tip_cond_trifazat and code == "FDCP":
                branch_value = "trifazat"
            else:
                branch_value = "monofazat"
                
            if code == "FDCS" and tip_cond in ["ACYABY 4X16", "ACYABY 4x16"]:
                vague = True
            
            if branch_value:
                feature["TIP_BR"] = branch_value
            layer.updateFeature(feature)
        
        if layer.commitChanges():
            if vague:
                QMessageBox.critical(None, "AVERTIZARE - TIP_BR - BRANS_FIRI_GRPM_JT", "⚠️ A fost găsit un caz special pentru FDCS si ACYABY 4X16! Verifică și completează manual.")
        else:
            QMessageBox.critical(None, "TIP_BR - BRANS_FIRI_GRPM_JT", "Eroare la actualizarea campului TIP_BR.")
            
    def update_uzu_stp_prop_fo(self):
        layers = QgsProject.instance().mapLayersByName('STALP_JT')
        if not layers:
            QgsMessageLog.logMessage("Layer 'STALP_JT' not found.", 'DesenAssist', Qgis.Critical)
            return
        layer = layers[0]
        
        if not layer.isEditable():
            layer.startEditing()
            
        field_names = [field.name() for field in layer.fields()]
        
        for feature in layer.getFeatures():
            if "NR_CIR_FO" in field_names and "PROP_FO" in field_names:
                nr_cir_fo = feature["NR_CIR_FO"]
                prop_fo = feature["PROP_FO"]
                if nr_cir_fo not in config.NULL_VALUES and prop_fo in config.NULL_VALUES:
                    layer.changeAttributeValue(feature.id(), layer.fields().indexFromName("PROP_FO"), "SC RCS&RDS S.A")
            
            if "UZURA_STP" in field_names:
                uzura_stp = feature["UZURA_STP"]
                if uzura_stp in config.NULL_VALUES:
                    layer.changeAttributeValue(feature.id(), layer.fields().indexFromName("UZURA_STP"), 5)
                    
        if not layer.commitChanges():
            QMessageBox.critical(None, "UZURA_STP si PROP_FO - STALP_JT", "Eroare la actualizarea coloanelor UZURA_STP si PROP_FO.")
            
    def verify_streets(self):
        self.process_layers(self.layers)

        def get_layer(layer_name):
            layers = QgsProject.instance().mapLayersByName(layer_name)
            if not layers:
                QgsMessageLog.logMessage(f"Layer '{layer_name}' not found.", 'DesenAssist', Qgis.Critical)
                return None
            return layers[0]

        br_layer = get_layer('BRANS_FIRI_GRPM_JT')
        st_layer = get_layer('STALP_JT')
        fb_layer = get_layer('FB pe C LES')

        if not (br_layer and st_layer and fb_layer):
            return

        for layer in [br_layer, st_layer, fb_layer]:
            layer.startEditing()
            for feature in layer.getFeatures():
                if feature.fields().lookupField("STR") != -1:
                    street = feature["STR"]
                    if street:
                        feature["STR"] = street.strip()
                        layer.updateFeature(feature)
                        
            layer.commitChanges()

        dialog = GenerateExcelDialog(self.base_dir)
        dialog.exec_()
        
