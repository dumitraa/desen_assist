# -*- coding: utf-8 -*-
"""
/***************************************************************************
 DesenAssist
                                 A QGIS plugin
 Helps in assisting in digitizing and QC of Low Voltage Underground Utility Poles for an internal workflow process
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2024-11-29
        git sha              : $Format:%H$
        copyright            : (C) 2024 by Ionela
        email                : ioneladumitra@yahoo.ro
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os
import os.path
from pathlib import Path
import random
import re

from PyQt5.QtCore import QVariant  # type: ignore
from qgis.PyQt.QtCore import QCoreApplication, QSettings, QTranslator, QVariant  # type: ignore
from qgis.PyQt.QtGui import QColor, QIcon  # type: ignore
from qgis.PyQt.QtWidgets import QAction, QFileDialog, QInputDialog, QMessageBox  # type: ignore
import processing  # type: ignore

from qgis.core import ( # type: ignore
    Qgis,
    QgsCategorizedSymbolRenderer,
    QgsFeature,
    QgsFeatureRequest,
    QgsField,
    QgsFields,
    QgsGeometry,
    QgsMessageLog,
    QgsPointXY,
    QgsProcessingContext,
    QgsProject,
    QgsSymbol,
    QgsCategorizedSymbolRenderer,
    QgsRendererCategory,
    QgsSpatialIndex,
    QgsVectorFileWriter,
    QgsVectorLayer,
    QgsWkbTypes,
    QgsFeatureRequest,
)

# Local imports
from . import config
from .func.generate_excel import GenerateExcelDialog
from .func.helper_functions import HelperBase, SHPProcessor
from .func.vector_verifier import VectorVerifier
from .resources import *

from .event_tracker import EditTracker
from .user_utils import get_current_user, get_plugin_version
from .api_client import send_event


class DesenAssist:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        self.context = QgsProcessingContext()
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        self.helper = HelperBase()
        self.processor = None
        self.current_user = get_current_user(parent=self.iface.mainWindow())
        self.tracker = EditTracker(self.iface, self.current_user)
        send_event(user=self.current_user, action="version", value=get_plugin_version())
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'DesenAssist_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&DesenAssist')
        
        self.layers = self.helper.get_layers()

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None


    @staticmethod
    def plugin_path(*args) -> Path:
        """ Return the path to the plugin root folder or file. """
        path = Path(__file__).resolve().parent
        for item in args:
            path = path.joinpath(item)
        return path


    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('DesenAssist', message)


    def add_action(
        self,
        name,
        text,
        callback=None,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None,
        icon_path=None,
        shortcut=None,):
        
        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.setEnabled(enabled_flag)

        if callback is not None:
            def wrapped():
                send_event(user=self.current_user, action="button", value=name)
                callback()
            action.triggered.connect(wrapped)
            action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)
            
        if shortcut is not None:
            action.setShortcut(shortcut)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            self.toolbar.addAction(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        self.toolbar = self.iface.addToolBar('DesenAssist')
        self.toolbar.setObjectName('DesenAssist')
        self.toolbar.setMovable(True)
        
        self.fisier_destinatie_action = self.add_action(
            "Fisier Destinatie",
            text=self.tr(u'Fisier Destinatie'),
            callback=self.set_base_dir,
            parent=self.iface.mainWindow(),
            icon_path= str(self.plugin_path('icons/folder.png')),
            enabled_flag=True
        )
        
        self.load_ui_action = self.add_action(
                "Incarca fisierele .ui",
                text=self.tr(u'Incarca fisierele .ui'),
                callback=self.load_ui_files,
                parent=self.iface.mainWindow(),
                icon_path = str(self.plugin_path('icons/ui.png')),
                enabled_flag=True
            )
        
        self.actions_to_enable = [
            self.add_action(
                "Separare posturi dupa ID_BDI",
                text=self.tr(u'Separare posturi dupa ID_BDI'),
                callback=self.prepare_and_separate,
                parent=self.iface.mainWindow(),
                icon_path= str(self.plugin_path('icons/separate.png')),
                enabled_flag=False
            ),
            self.add_action(
                "Separare posturi dupa selectie",
                text=self.tr(u'Separare posturi dupa selectie'),
                callback=self.separate_poles_by_selection,
                parent=self.iface.mainWindow(),
                icon_path= str(self.plugin_path('icons/select.png')),
                enabled_flag=False
            ),
            self.add_action(
                "Ajustare bransamente la 1m",
                text=self.tr(u'Ajustare bransamente la 1m'),
                callback=self.cut_bpmp,
                parent=self.iface.mainWindow(),
                icon_path= str(self.plugin_path('icons/cut.png')),
                enabled_flag=True
            ),
            self.add_action(
                "Completare câmpuri",
                text=self.tr(u'Completare câmpuri'),
                callback=self.complete_fields,
                parent=self.iface.mainWindow(),
                icon_path= str(self.plugin_path('icons/autocomplete.png')),
                enabled_flag=True
            ),
            self.add_action(
                "Verificare numerotare stâlpi",
                text=self.tr(u'Verificare numerotare stâlpi'),
                callback=self.verify_pole_numbering,
                parent=self.iface.mainWindow(),
                icon_path= str(self.plugin_path('icons/num.png')),
                enabled_flag=True
            ),
            self.add_action(
                "Verificare denumire străzi - STALP_JT, BRANS_FIRI_GRPM_JT",
                text=self.tr(u'Verificare denumire străzi - STALP_JT, BRANS_FIRI_GRPM_JT'),
                callback=self.verify_street_names,
                parent=self.iface.mainWindow(),
                icon_path= str(self.plugin_path('icons/street.png')),
                enabled_flag=True
            ),
            self.add_action(
                "Corespondență LINIA_JT - TRONSON_JT cu BRANS_FIRI_GRPM_JT",
                text=self.tr(u'Corespondență LINIA_JT - TRONSON_JT cu BRANS_FIRI_GRPM_JT'),
                callback=self.verify_linia_jt_matches,
                parent=self.iface.mainWindow(),
                icon_path= str(self.plugin_path('icons/mapping.png')),
                enabled_flag=True
            ),
            self.add_action(
                "Verificare coloane",
                text=self.tr(u'Verificare coloane'),
                callback=self.verify_mandatory_columns,
                parent=self.iface.mainWindow(),
                icon_path= str(self.plugin_path('icons/mandatory.png')),
                enabled_flag=True
            ),
            self.add_action(
                "Verificare circuit greșit",
                text=self.tr(u'Verificare circuit greșit'),
                callback=self.verify_circuit,
                parent=self.iface.mainWindow(),
                icon_path= str(self.plugin_path('icons/circuit.png')),
                enabled_flag=True
            ),
            self.add_action(
                "Verificare strazi si generare excel",
                text=self.tr(u'Verificare strazi si generare excel'),
                callback=self.verify_streets,
                parent=self.iface.mainWindow(),
                icon_path= str(self.plugin_path('icons/excel.png')),
                enabled_flag=False
            ),
            self.add_action(
                "Verificare vectoriala",
                text=self.tr(u'Verificare vectoriala'),
                callback=self.verify_vector,
                parent=self.iface.mainWindow(),
                icon_path= str(self.plugin_path('icons/vector.png')),
                enabled_flag=True
            )
        ]
        
        self.action_length = self.add_action(
            "Lungime PT",
            text=self.tr(u"Lungime TRONSON_JT: apasă pentru calcul"),
            callback=self.trigger_calc_length,
            parent=self.iface.mainWindow(),
        )
        
        self.first_start = True

    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(self.tr(u'&Desen Assist'), action)
            self.toolbar.removeAction(action)
        del self.toolbar
        if hasattr(self, 'tracker'):
            self.tracker.finalize()
        
    def set_base_dir(self):
        project = QgsProject.instance()
        missing_layers = []
        layers = {}
        
        required_layers = ["BRANS_FIRI_GRPM_JT", "FB pe C LES", "TRONSON_JT", "STALP_JT", "LINIE_JT"]
        
        for layer_name in required_layers:
            found_layers = project.mapLayersByName(layer_name)
            if not found_layers:
                missing_layers.append(layer_name)
            else:
                layers[layer_name] = found_layers[0]
        
        if missing_layers:
            QMessageBox.critical(None, "Eroare", f"Urmatoarele straturi lipsesc: {', '.join(missing_layers)}. Asigură-te că straturile există în proiect și au denumirile corecte.")
            return

        self.layers = layers
        
        base_dir = QFileDialog.getExistingDirectory(None, "Selectați folder-ul de bază", "")
        if base_dir:
            self.base_dir = base_dir
            self.fisier_destinatie_action.setIcon(QIcon(str(self.plugin_path('icons/complete.png'))))
            for action in self.actions_to_enable:
                action.setEnabled(True)

        
    def get_layer_path(self, layer_name):
        """
        Get the full data source path of a layer by its name.

        Parameters:
            layer_name (str): The name of the layer in the QGIS project.

        Returns:
            str: The full data source path of the layer, including `|layername=`.
                Returns None if the layer is not found.
        """
        layers = QgsProject.instance().mapLayersByName(layer_name)
        if not layers:
            return None
        
        layer = layers[0]
        data_source = layer.dataProvider().dataSourceUri()
        
        if layer.storageType() == "GeoPackage" and "|layername=" not in data_source:
            data_source += f"|layername={layer.name()}"
        
        return data_source

    def clean_denum(self, denum):
        denum = str(denum)
        if denum:
            match = re.match(r'(\d+)([A-Za-z]*)', denum)
            if match:
                numeric_part = int(match.group(1))
                alpha_part = match.group(2).upper()
                return (numeric_part, alpha_part)
        return (float('inf'), '')

    def process_layers(self, layers):
        if not self.processor:
            try:
                self.processor = SHPProcessor(layers)
            except Exception as e:
                return
        
        try:
            current_layers = self.helper.get_layers()
        except Exception as e:
            return
        
        if current_layers != layers:
            self.processor = None
            
            try:
                self.processor = SHPProcessor(current_layers)
            except Exception as e:
                return
        else:
            return
        
    def create_scratch_layer(self, name, geom_type):
        crs = "EPSG:3844"
        if geom_type == "Point":
            uri = f"Point?crs={crs}"
        elif geom_type == "LineString":
            uri = f"LineString?crs={crs}"
        else:
            uri = f"None?crs={crs}"

        layer = QgsVectorLayer(uri, name, "memory")
        provider = layer.dataProvider()

        fields = QgsFields()
        fields.append(QgsField("nume_layer", QVariant.String))  
        fields.append(QgsField("coloane", QVariant.String))     
        fields.append(QgsField("feature_id", QVariant.Int))
        provider.addAttributes(fields)
        layer.updateFields()
        return layer

    def load_ui_files(self):
        folder_path_ui = self.plugin_path('func', 'templates', 'uis')
        layers = []

        for filename in os.listdir(folder_path_ui):
            if filename.endswith('.ui'):
                ui_file_path = os.path.join(folder_path_ui, filename)
                layer_name = filename[:-3]
                layer_list = QgsProject.instance().mapLayersByName(layer_name)
                if layer_list:
                    layer = layer_list[0]
                    # Get current form configuration and set the UI file.
                    edit_form_config = layer.editFormConfig()
                    edit_form_config.setUiForm(ui_file_path)
                    layer.setEditFormConfig(edit_form_config)
                    layers.append(layer_name)
                else:
                    QMessageBox.critical(None, "Eroare", f"Layerul {layer_name} nu a fost găsit în proiect.")
                    return

        QMessageBox.information(None, "Incarcare UI", f"Stilurile UI pentru layerele {', '.join(layers)} au fost încărcate cu succes.")

        self.load_ui_action.setIcon(QIcon(str(self.plugin_path('icons/ui_done.png'))))

    def prepare_and_separate(self):
        success = self.assign_id_bdis(self.layers)
        
        if success:
            self.separate_poles_by_id(self.layers)
        else:
            QMessageBox.critical(None, "Eroare", "Eroare la asignarea ID_BDI")
    
    def assign_id_bdis(self, layers):
        """
        Completes ID_BDI for BRANS_FIRI_GRPM_JT, FB_pe_C_LES, TRONSON_JT by mapping from their LINIE_JT - which corresponds to DENUM from layer LINIA_JT (which also has ID_BDI)
        Completes ID_BDI for STALP_JT by getting the intersected TRONSON_JT's ID_BDI. If multiple intersecting TRONSON_JT features have different ID_BDI values, assign the most frequent one.
        If no intersection is found in TRONSON_JT, checks for intersections in BRANS_FIRI_GRPM_JT.
        """
        
        # Create dictionary for LINIE_JT mapping (DENUM -> ID_BDI)
        linia_jt_layer = layers["LINIE_JT"]
        linia_jt_mapping = {feat["DENUM"]: feat["ID_BDI"] for feat in linia_jt_layer.getFeatures()}
        
        # Update ID_BDI for BRANS_FIRI_GRPM_JT, FB pe C LES, TRONSON_JT based on LINIA_JT
        for layer_name in ["BRANS_FIRI_GRPM_JT", "FB pe C LES", "TRONSON_JT"]:
            layer = layers[layer_name]
            layer.startEditing()
            for feature in layer.getFeatures():
                linia_denum = feature["LINIA_JT"]
                if linia_denum in linia_jt_mapping:
                    feature["ID_BDI"] = linia_jt_mapping[linia_denum]
                    layer.updateFeature(feature)
            layer.commitChanges()
            send_event(user=self.current_user, action="auto_complete", layer=layer.name())
        
        # Spatially join ID_BDI from TRONSON_JT to STALP_JT
        tronson_jt_layer = layers["TRONSON_JT"]
        bransament_jt_layer = layers["BRANS_FIRI_GRPM_JT"]
        stalp_jt_layer = layers["STALP_JT"]
        
        spatial_index_tr = QgsSpatialIndex(tronson_jt_layer.getFeatures())
        spatial_index_br = QgsSpatialIndex(bransament_jt_layer.getFeatures())
        
        stalp_jt_layer.startEditing()
        for stalp in stalp_jt_layer.getFeatures():
            intersecting_ids_tr = spatial_index_tr.intersects(stalp.geometry().boundingBox())
            
            id_bdi_value = None
            
            # First, try to get ID_BDI from intersecting TRONSON_JT
            if intersecting_ids_tr:
                for tronson in tronson_jt_layer.getFeatures(QgsFeatureRequest().setFilterFids(intersecting_ids_tr)):
                    if stalp.geometry().intersects(tronson.geometry()):
                        id_bdi_value = tronson["ID_BDI"]
                        if id_bdi_value:  # If found, no need to check further
                            break
            
            # If no ID_BDI found in TRONSON_JT, check BRANS_FIRI_GRPM_JT
            if not id_bdi_value:
                intersecting_ids_br = spatial_index_br.intersects(stalp.geometry().boundingBox())
                
                if intersecting_ids_br:
                    for bransament in bransament_jt_layer.getFeatures(QgsFeatureRequest().setFilterFids(intersecting_ids_br)):
                        if stalp.geometry().intersects(bransament.geometry()):
                            id_bdi_value = bransament["ID_BDI"]
                            if id_bdi_value:
                                break  # Stop as soon as one is found
            
            # Assign the found ID_BDI to the STALP_JT feature
            if id_bdi_value:
                stalp["ID_BDI"] = id_bdi_value
                stalp_jt_layer.updateFeature(stalp)

        stalp_jt_layer.commitChanges()
        send_event(user=self.current_user, action="auto_complete", layer=stalp_jt_layer.name())
        return True


    def separate_poles_by_id(self, layers):
        """
        Filters all layers based on user-input ID_BDI values and exports them into single .gpkg files per layer type.
        """
        id_bdis, ok = QInputDialog.getText(None, "Input ID_BDI", "ID_BDI:")

        if ok and not id_bdis:
            QMessageBox.warning(None, "Input Error", "ID_BDI nu a fost introdus.")
            return

        if id_bdis:
            # Convert input IDs to a list
            id_bdi_list = [id_bdi.strip() for id_bdi in id_bdis.split(",") if id_bdi.strip()]
            
            # Access the layers
            linie_jt_layer = layers["LINIE_JT"]
            stalp_jt_layer = layers["STALP_JT"]
            brans_layer = layers["BRANS_FIRI_GRPM_JT"]
            fb_les_layer = layers["FB pe C LES"]
            tronson_layer = layers["TRONSON_JT"]
            
            # Define layers to filter
            layers_to_filter = {
                "LINIE_JT": linie_jt_layer,
                "STALP_JT": stalp_jt_layer,
                "BRANS_FIRI_GRPM_JT": brans_layer,
                "FB pe C LES": fb_les_layer,
                "TRONSON_JT": tronson_layer
            }
            
            base_dir = self.base_dir
            if not os.path.exists(base_dir):
                os.makedirs(base_dir)
            
            # Create a new group in QGIS
            root = QgsProject.instance().layerTreeRoot()
            new_group = root.addGroup(f"Date_Filtrate_{'_'.join(id_bdi_list)}")
            
            missing_id_bdis = []
            
            for id_bdi in id_bdi_list:
                found = False
                for feature in linie_jt_layer.getFeatures():
                    if str(feature["ID_BDI"]) == id_bdi:
                        found = True
                        break
                if not found:
                    missing_id_bdis.append(id_bdi)
            
            for layer_name, original_layer in layers_to_filter.items():
                # Retrieve geometry type and CRS
                geometry_type = QgsWkbTypes.displayString(original_layer.wkbType())
                crs = original_layer.crs().authid()
                
                # Create a new in-memory layer
                new_layer = QgsVectorLayer(f"{geometry_type}?crs={crs}", layer_name, "memory")
                new_layer_data = new_layer.dataProvider()
                new_layer_data.addAttributes(original_layer.fields())
                new_layer.updateFields()
                
                # Collect all matching features
                matching_features = []
                for feature in original_layer.getFeatures():
                    if str(feature["ID_BDI"]) in id_bdi_list:
                        matching_features.append(QgsFeature(feature))
                
                # Add filtered features to new layer (even if empty)
                new_layer_data.addFeatures(matching_features)
                new_layer.updateExtents()
                                            
                # Export to GeoPackage
                output_path = os.path.join(base_dir, f"{layer_name}.gpkg")
                QgsVectorFileWriter.writeAsVectorFormat(
                    new_layer, output_path, "UTF-8", original_layer.crs(), "GPKG"
                )
                
                permanent_layer = QgsVectorLayer(output_path, layer_name, "ogr")
                QgsProject.instance().addMapLayer(permanent_layer, False)
                new_group.addLayer(permanent_layer)
                
                if layer_name != "LINIE_JT" and original_layer:
                    orig_renderer = original_layer.renderer()
                    if orig_renderer is not None:
                        permanent_layer.setRenderer(orig_renderer.clone())
                    else:
                        print(f"Warning: No renderer found for {layer_name}.")

                    # Clone labeling if enabled and available
                    if original_layer.labelsEnabled() and original_layer.labeling() is not None:
                        permanent_layer.setLabeling(original_layer.labeling().clone())
                        permanent_layer.setLabelsEnabled(True)

                    permanent_layer.triggerRepaint()
            
            QMessageBox.information(None, "Success", "Layerele filtrate au fost salvate cu succes")
            
            if missing_id_bdis:
                QMessageBox.warning(None, "ID_BDI lipsă în LINIE_JT", f"ID_BDI lipsă în LINIE_JT: {', '.join(missing_id_bdis)}")
                
    def separate_poles_by_selection(self):
        '''
        based on a selection or a drawn polygon, get all features from the layers and save them in new layers with the same names, saving them to self.base_dir
        '''
        
        layer_names = ["STALP_JT", "BRANS_FIRI_GRPM_JT", "FB pe C LES", "TRONSON_JT"]
        missing_layers = []
        
        for layer_name in layer_names:
            layer = QgsProject.instance().mapLayersByName(layer_name)
            if not layer:
                missing_layers.append(layer_name)
                
        if missing_layers:
            QMessageBox.critical(None, "Eroare", f"Urmatoarele straturi lipsesc: {', '.join(missing_layers)}. Asigură-te că straturile există în proiect și au denumirile corecte.")
            return
        
        layers = {
            "STALP_JT": QgsProject.instance().mapLayersByName("STALP_JT")[0],
            "BRANS_FIRI_GRPM_JT": QgsProject.instance().mapLayersByName("BRANS_FIRI_GRPM_JT")[0],
            "FB pe C LES": QgsProject.instance().mapLayersByName("FB pe C LES")[0],
            "TRONSON_JT": QgsProject.instance().mapLayersByName("TRONSON_JT")[0]
            }

        polygon_layer_name = "poligon"

        polygon_layers = QgsProject.instance().mapLayersByName(polygon_layer_name)
        polygon_layer = polygon_layers[0] if polygon_layers else None

        if not polygon_layer or polygon_layer.featureCount() == 0:
            temp_crs = QgsProject.instance().crs()
            temp_layer = QgsVectorLayer(
                "Polygon?crs={}".format(temp_crs.authid()), 
                polygon_layer_name, 
                "memory"
            )

            QgsProject.instance().addMapLayer(temp_layer)
            QMessageBox.information(None, "Poligon", "Deseneaza poligonul pe zona dorita si apoi apasa din nou pe buton.")
            
            # make layer editable, enable "add polygon feature" to start drawing immeately
            temp_layer.startEditing()
            self.iface.setActiveLayer(temp_layer)
            self.iface.actionAddFeature().trigger()
            return
            

        if polygon_layer.featureCount() != 1:
            QMessageBox.warning(
                None,
                "Poligon invalid",
                f"Layerul {polygon_layer_name} trebuie să conțină un singur poligon."
            )
            return

        polygon_feature = next(polygon_layer.getFeatures())
        polygon_geom = polygon_feature.geometry()
        
        stalp_jt_layer = layers["STALP_JT"]
        brans_layer = layers["BRANS_FIRI_GRPM_JT"]
        fb_les_layer = layers["FB pe C LES"]
        tronson_layer = layers["TRONSON_JT"]

        layers_to_filter = {
            "STALP_JT": stalp_jt_layer,
            "BRANS_FIRI_GRPM_JT": brans_layer,
            "FB pe C LES": fb_les_layer,
            "TRONSON_JT": tronson_layer
        }

        base_dir = self.base_dir
        if not os.path.exists(base_dir):
            os.makedirs(base_dir)

        root = QgsProject.instance().layerTreeRoot()
        group_name = f"Date_Filtrate_{polygon_layer_name}"
        new_group = root.addGroup(group_name)

        for layer_name, original_layer in layers_to_filter.items():
            geometry_type = QgsWkbTypes.displayString(original_layer.wkbType())
            crs = original_layer.crs().authid()

            # Create a temporary in-memory layer
            new_layer = QgsVectorLayer(f"{geometry_type}?crs={crs}", layer_name, "memory")
            new_layer_data = new_layer.dataProvider()
            new_layer_data.addAttributes(original_layer.fields())
            new_layer.updateFields()

            # Filter features intersecting polygon_geom and add them to the temporary layer
            matching_features = []
            for feature in original_layer.getFeatures():
                if feature.geometry() and feature.geometry().intersects(polygon_geom):
                    matching_features.append(QgsFeature(feature))
            new_layer_data.addFeatures(matching_features)
            new_layer.updateExtents()

            # Save the temporary layer to disk (GeoPackage)
            output_path = os.path.join(base_dir, f"{layer_name}.gpkg")
            QgsVectorFileWriter.writeAsVectorFormat(
                new_layer, output_path, "UTF-8", original_layer.crs(), "GPKG"
            )

            # Load the saved layer as the permanent layer
            permanent_layer = QgsVectorLayer(output_path, layer_name, "ogr")
            QgsProject.instance().addMapLayer(permanent_layer, False)
            new_group.addLayer(permanent_layer)
            
            if original_layer:
                orig_renderer = original_layer.renderer()
                if orig_renderer is not None:
                    permanent_layer.setRenderer(orig_renderer.clone())
                else:
                    print(f"Warning: No renderer found for {layer_name}.")

                # Clone labeling if enabled and available
                if original_layer.labelsEnabled() and original_layer.labeling() is not None:
                    permanent_layer.setLabeling(original_layer.labeling().clone())
                    permanent_layer.setLabelsEnabled(True)

                permanent_layer.triggerRepaint()


        QMessageBox.information(None, "Succes", "Layerele filtrate au fost salvate cu succes.")


    def complete_fields(self):
        # verify if the layers are loaded
        layers = ["STALP_JT", "BRANS_FIRI_GRPM_JT", "FB pe C LES", "TRONSON_JT"]
        missing_layers = []
        
        for layer_name in layers:
            layer = QgsProject.instance().mapLayersByName(layer_name)
            if not layer:
                missing_layers.append(layer_name)
                
        if missing_layers:
            QMessageBox.critical(None, "Eroare", f"Urmatoarele straturi lipsesc: {', '.join(missing_layers)}. Asigură-te că straturile există în proiect și au denumirile corecte.")
            return
        
        st = QgsProject.instance().mapLayersByName("STALP_JT")[0]
        br = QgsProject.instance().mapLayersByName("BRANS_FIRI_GRPM_JT")[0]
        tr = QgsProject.instance().mapLayersByName("TRONSON_JT")[0]
        
        updated_layers = set()

        self.update_nr_circuite(st, tr, br)
        updated_layers.add(st)

        self.update_branch_fields(br)
        updated_layers.add(br)

        self.update_prop_column(st)
        updated_layers.add(st)

        self.update_tip_fund(st)
        updated_layers.add(st)

        self.update_true_false_columns(st)
        updated_layers.add(st)

        self.update_uzu_stp_prop_fo(st)
        updated_layers.add(st)

        for layer in updated_layers:
            send_event(user=self.current_user, action="auto_complete", layer=layer.name())
        
        QMessageBox.information(None, "Completare campuri", "Campurile au fost completate cu succes.")

    def cut_bpmp(self):
        # Retrieve the layers
        br_layers = QgsProject.instance().mapLayersByName("BRANS_FIRI_GRPM_JT")
        
        if not br_layers:
            QMessageBox.warning(None, "Eroare", "Stratul BRANS_FIRI_GRPM_JT nu a fost găsit.")
            return

        br_layer = br_layers[0]

        # Define field names to check
        br_field = "TIP_FIRI_BR"
        cond_field = "TIP_COND"

        if not br_layer.isEditable():
            br_layer.startEditing()

        # Iterate through each feature
        for feat in br_layer.getFeatures():
            if feat[br_field] in ("BMPM", "BMPT", "FDCS", "FDCP") and feat[cond_field] not in ["ACYABY 4X16", "ACYABY 4x16"]:
                geom = feat.geometry()
                if geom.isMultipart():
                    continue

                points = geom.asPolyline()
                # Require at least two vertices to define a segment
                if len(points) < 2:
                    continue

                # Identify the last segment endpoints
                p_second_last = points[-2]
                p_last = points[-1]

                # Compute the current segment length
                current_length = p_second_last.distance(p_last)
                # Avoid division by zero
                if current_length == 0:
                    continue

                # Compute the normalized direction vector from the second-last to the last vertex
                dx = p_last.x() - p_second_last.x()
                dy = p_last.y() - p_second_last.y()
                norm = (dx**2 + dy**2)**0.5
                ndx = dx / norm
                ndy = dy / norm

                # The new last vertex is positioned 1 meter from the second-last vertex,
                # regardless of whether that means shortening or extending the segment.
                new_last = QgsPointXY(p_second_last.x() + ndx * 1.0,
                                    p_second_last.y() + ndy * 1.0)
                points[-1] = new_last

                # Reconstruct the geometry with the adjusted vertex
                new_geom = QgsGeometry.fromPolylineXY(points)
                # Update the feature's geometry in the layer
                br_layer.changeGeometry(feat.id(), new_geom)

        # Commit all changes made during the edit session
        br_layer.commitChanges()
        QMessageBox.information(None, "Success", "Bransamentele BMPM, BMPT, FDCS și FDCP (cu exceptia celor cu TIP_COND = ACYABY 4x16) au fost ajustate la 1 metru.")


# A.	Verificare numerotare stalpi
    def verify_pole_numbering(self):
        self.verify_br()
        self.verify_jt()
    
    def verify_jt(self):
        # Step 1: Get the original layer
        original_layers = QgsProject.instance().mapLayersByName("STALP_JT")
        
        if not original_layers:
            QMessageBox.warning(None, "Eroare", "Stratul STALP_JT nu a fost găsit.")
            return
        
        original_layer = original_layers[0]

        # Step 2: Filter features with "JT" in the "TIP_CIR" field
        jt_features = sorted(
            [f for f in original_layer.getFeatures() if "JT" in f["TIP_CIR"]],
            key=lambda f: int(f["DENUM"])
        )

        # Step 3: Create a new scratch layer
        scratch_layer = QgsVectorLayer(
            "Point?crs=" + original_layer.crs().toWkt(), 
            "Verificare_Numerotare_Stalpi_JT", 
            "memory"
        )
        scratch_layer_data = scratch_layer.dataProvider()

        # Add only the necessary fields
        fields = QgsFields()
        fields.append(QgsField("fid", QVariant.Int))
        fields.append(QgsField("TIP_CIR", QVariant.String))
        fields.append(QgsField("ID_PROVIZ", QVariant.Int))
        fields.append(QgsField("DENUM", QVariant.String))
        fields.append(QgsField("MATCH_STATUS", QVariant.String))
        scratch_layer_data.addAttributes(fields)
        scratch_layer.updateFields()

        for idx, feature in enumerate(jt_features, start=1):
            idx = idx - 1
            
            new_feature = QgsFeature()
            new_feature.setGeometry(feature.geometry())
            new_feature.setFields(scratch_layer.fields())

            new_feature["fid"] = feature.id()
            new_feature["TIP_CIR"] = feature["TIP_CIR"]
            new_feature["ID_PROVIZ"] = idx
            new_feature["DENUM"] = feature["DENUM"]
            new_feature["MATCH_STATUS"] = "Da" if idx == int(feature["DENUM"]) else "Nu"
            
            scratch_layer_data.addFeature(new_feature)


        # Add the scratch layer to the project
        self.helper.add_layer_to_de_verificat(scratch_layer)

    def verify_br(self):
        original_layers = QgsProject.instance().mapLayersByName("STALP_JT")
        
        if not original_layers:
            QMessageBox.warning(None, "Eroare", "Stratul STALP_JT nu a fost găsit.")
            return
        
        original_layer = original_layers[0]

        # Uppercase the DENUM field in the original layer and save changes
        original_layer.startEditing()
        for feature in original_layer.getFeatures():
            denum = feature["DENUM"]
            if denum:
                feature["DENUM"] = denum.upper()
                original_layer.updateFeature(feature)
        original_layer.commitChanges()
        send_event(user=self.current_user, action="auto_complete", layer=original_layer.name())

        jt_features = [f for f in original_layer.getFeatures() if "BR" in f["TIP_CIR"] and "JT" not in f["TIP_CIR"]]
        jt_features_sorted = sorted(jt_features, key=lambda f: self.clean_denum(f["DENUM"]))

        # Create a new scratch layer for BR features
        scratch_layer = QgsVectorLayer(
            "Point?crs=" + original_layer.crs().toWkt(),
            "Verificare_Numerotare_Stalpi_Auxiliari",
            "memory"
        )
        scratch_layer_data = scratch_layer.dataProvider()

        # Add only the necessary fields
        fields = QgsFields()
        fields.append(QgsField("fid", QVariant.Int))  # Original feature ID
        fields.append(QgsField("TIP_CIR", QVariant.String))
        fields.append(QgsField("DENUM", QVariant.String))
        scratch_layer_data.addAttributes(fields)
        scratch_layer.updateFields()

        # Populate the new layer with sorted features and compute new fields
        for idx, feature in enumerate(jt_features_sorted):  # Enumerate in the sorted DENUM order
            new_feature = QgsFeature()
            new_feature.setGeometry(feature.geometry())
            new_feature.setFields(scratch_layer.fields())

            # Add new fields
            new_feature["fid"] = feature.id()
            new_feature["TIP_CIR"] = feature["TIP_CIR"]
            new_feature["DENUM"] = feature["DENUM"]

            # Add feature to the scratch layer
            scratch_layer_data.addFeature(new_feature)

        # Add the scratch layer to the project
        self.helper.add_layer_to_de_verificat(scratch_layer)


# C.	Coloana “linie jt” sa fie la fel la bransament si la tronson - WORKING
    def verify_linia_jt_matches(self):
        '''
        Checks for mismatched LINIA_JT values between intersecting features
        in BRANS_FIRI_GRPM_JT and TRONSON_JT layers.
        For every BRANS feature, each intersecting TRONSON feature is examined.
        If the LINIA_JT values differ, a record is added to a scratch layer.
        The scratch layer contains three fields:
        "fid" - the BRANS feature ID,
        "TRONSON_JT_LINIA_JT" - the LINIA_JT value from the TRONSON feature,
        "BRANSAMENT_LINIA_JT" - the LINIA_JT value from the BRANS feature.
        '''
        # Load layers
        brans_layers = QgsProject.instance().mapLayersByName('BRANS_FIRI_GRPM_JT')
        tronson_layers = QgsProject.instance().mapLayersByName('TRONSON_JT')
        
        missing_layers = []
        if not brans_layers:
            missing_layers.append('BRANS_FIRI_GRPM_JT')
        if not tronson_layers:
            missing_layers.append('TRONSON_JT')
        if missing_layers:
            QMessageBox.critical(None, "Eroare", f"Urmatoarele straturi lipsesc: {', '.join(missing_layers)}. Asigură-te că straturile există în proiect și au denumirile corecte.")
            return
        
        brans_layer = brans_layers[0]
        tronson_layer = tronson_layers[0]
        
        # Build a spatial index for TRONSON layer for efficient querying.
        tronson_index = QgsSpatialIndex(tronson_layer.getFeatures())
        
        mismatches = []
        
        # Iterate over each BRANS feature.
        for brans_feature in brans_layer.getFeatures():
            brans_linia = brans_feature["LINIA_JT"]
            if not brans_linia:
                continue
            brans_geom = brans_feature.geometry()
            
            # Find candidate TRONSON features that intersect the BRANS feature’s bounding box.
            candidate_ids = tronson_index.intersects(brans_geom.boundingBox())
            for cand_id in candidate_ids:
                tronson_feature = tronson_layer.getFeature(cand_id)
                if brans_geom.intersects(tronson_feature.geometry()):
                    tronson_linia = tronson_feature["LINIA_JT"]
                    # If the LINIA_JT values differ, record this mismatch.
                    if tronson_linia != brans_linia:
                        new_feature = QgsFeature()
                        new_feature.setGeometry(brans_geom)
                        new_feature.setAttributes([str(brans_feature.id()), tronson_linia, brans_linia])
                        mismatches.append(new_feature)
        
        if mismatches:
            scratch_layer = QgsVectorLayer("LineString?crs=EPSG:3844", "LINIA_JT_verificare", "memory")
            fields = QgsFields()
            fields.append(QgsField("fid", QVariant.String))
            fields.append(QgsField("TRONSON_JT_LINIA_JT", QVariant.String))
            fields.append(QgsField("BRANSAMENT_LINIA_JT", QVariant.String))
            scratch_layer.dataProvider().addAttributes(fields)
            scratch_layer.updateFields()
            
            scratch_layer.dataProvider().addFeatures(mismatches)
            scratch_layer.commitChanges()
            self.helper.add_layer_to_de_verificat(scratch_layer)
            
            QMessageBox.information(None, "LINIA_JT", 
                "Au fost gasite linii JT cu valori diferite intre BRANS_FIRI_GRPM_JT si TRONSON_JT.")
        else:
            QMessageBox.information(None, "LINIA_JT", 
                "Toate campurile de LINIA_JT corespund intre BRANS_FIRI_GRPM_JT si TRONSON_JT.")

        
    def verify_street_names(self):
        self.verify_street_names_poles()
        self.verify_street_brans()
        
        QMessageBox.information(None, "STR", 
            "Denumirile străzilor pentru bransamente și stâlpi au fost verificate cu succes. Verifică straturile adăugate pentru detalii.")


    def verify_street_brans(self):
        brans_layer_name = "BRANS_FIRI_GRPM_JT"
        stalp_layer_name = "STALP_JT"

        brans_layer = QgsProject.instance().mapLayersByName(brans_layer_name)
        stalp_layer = QgsProject.instance().mapLayersByName(stalp_layer_name)

        missing_layers = []
        if not brans_layer:
            missing_layers.append(brans_layer_name)
        if not stalp_layer:
            missing_layers.append(stalp_layer_name)
            
        if missing_layers:
            QMessageBox.critical(None, "Eroare", f"Urmatoarele straturi lipsesc: {', '.join(missing_layers)}. Asigură-te că straturile există în proiect și au denumirile corecte.")
            return

        brans_layer = brans_layer[0]
        stalp_layer = stalp_layer[0]

        context = QgsProcessingContext()

        params = {
            'INPUT': brans_layer,
            'JOIN': stalp_layer,
            'PREDICATE': [0],  # Intersects
            'JOIN_FIELDS': ['STR'],  # Join the STR field from the stalp layer
            'METHOD': 0,  # Create temporary layer
            'DISCARD_NONMATCHING': False,
            'OUTPUT': 'memory:'  # Output to memory
        }

        try:
            join_output = processing.run("native:joinattributesbylocation", params, context=context)
            joined_layer = join_output['OUTPUT']

            uri = f"LineString?crs={brans_layer.crs().authid()}"
            non_match_layer = QgsVectorLayer(uri, "Validare_denumiri_strazi_bransamente", "memory")
            non_match_dp = non_match_layer.dataProvider()
            non_match_dp.addAttributes([
                QgsField("BRANSAMENT_fid", QVariant.Int),
                QgsField("BRANSAMENT_STR", QVariant.String),
                QgsField("STALP_STR", QVariant.String)
            ])
            non_match_layer.updateFields()

            diff_features = []
            for feature in joined_layer.getFeatures():
                brans_street = feature['STR']
                stalp_street = feature['STR_2']
                if brans_street != stalp_street:
                    new_feature = QgsFeature(non_match_layer.fields())
                    new_feature.setAttribute("BRANSAMENT_fid", feature.id())
                    new_feature.setAttribute("BRANSAMENT_STR", brans_street)
                    new_feature.setAttribute("STALP_STR", stalp_street)
                    new_feature.setGeometry(feature.geometry())
                    diff_features.append(new_feature)

            non_match_dp.addFeatures(diff_features)
            non_match_layer.updateExtents()

            self.helper.add_layer_to_de_verificat(non_match_layer)

        except Exception as e:
            QgsMessageLog.logMessage(f"An error occurred: {e}", 'DesenAssist', Qgis.Critical)
            return


    def verify_street_names_poles(self):
        def normalize_text(text):
            replacements = {
                'ă': 'a', 'â': 'a', 'î': 'i', 'ș': 's', 'ş': 's', 'ț': 't', 'ţ': 't',
                'Ă': 'A', 'Â': 'A', 'Î': 'I', 'Ș': 'S', 'Ş': 'S', 'Ț': 'T', 'Ţ': 'T'
            }
            for diacritic, replacement in replacements.items():
                text = text.replace(diacritic, replacement)
            return text
        
        missing_layers = []
        orig_layer = QgsProject.instance().mapLayersByName('STALP_JT')
        nr_postale_layer = QgsProject.instance().mapLayersByName('nr_postale')
        
        if not orig_layer:
            missing_layers.append('STALP_JT')
        if not nr_postale_layer:
            missing_layers.append('nr_postale')
            
        if missing_layers:
            QMessageBox.critical(None, "Eroare", f"Urmatoarele straturi lipsesc: {', '.join(missing_layers)}. Asigură-te că straturile există în proiect și au denumirile corecte.")
            return
        
        nr_postale_layer = nr_postale_layer[0]
        orig_layer = orig_layer[0]

        memory_layer = QgsVectorLayer("Point?crs=EPSG:3844", "STALP_JT_verificare_denum", "memory")
        dp = memory_layer.dataProvider()
        
        new_fields = QgsFields()
        new_fields.append(QgsField("fid", QVariant.Int))
        new_fields.append(QgsField("STR", QVariant.String))
        dp.addAttributes(new_fields)
        memory_layer.updateFields()

        denumire_d_values = set()
        for feature in nr_postale_layer.getFeatures():
            denumire_d = feature['DENUMIRE_D']
            if denumire_d:
                denumire_d_values.add(normalize_text(denumire_d))

        memory_layer.startEditing()
        for feature in orig_layer.getFeatures():
            str_value = feature['STR']
            if str_value:
                norm_str = normalize_text(str_value)
                if norm_str not in denumire_d_values:
                    new_feat = QgsFeature()
                    new_feat.setGeometry(feature.geometry())
                    new_feat.setFields(new_fields)
                    new_feat['fid'] = feature.id()
                    new_feat['STR'] = norm_str
                    dp.addFeatures([new_feat])
        memory_layer.commitChanges()

        self.helper.add_layer_to_de_verificat(memory_layer)
        QgsProject.instance().write()

    def verify_mandatory_columns(self):
        self.verify_num_columns()
        layers_to_check = {
            "STALP_JT": [
                "DENUM", "NR_INS_STP", "PROP", "JUD", "PRIM", "LOC", "TIP_STR", "STR", 
                "TIP_CIR", "DESC_CTG_MT_JT", "NR_CIR", "UZURA_STP", "TIP_FUND", 
                "ADAOS", "TIP_LEG_JT", "fid"],
            "BRANS_FIRI_GRPM_JT": [
                "fid", "TIP_BR", "TIP_COND", "JUD", "PRIM", "LOC", "TIP_STR", "STR", 
                "NR_IMOB", "TIP_FIRI_BR", "LINIA_JT"],
            "TRONSON_JT": [
                "TIP_TR", "TIP_COND", "fid", "LINIA_JT"],
            "FB pe C LES": [
                "fid", "TIP_BR", "TIP_COND", "JUD", "PRIM", "LOC", "TIP_STR", 
                "STR", "NR_IMOB", "TIP_FIRI_BR", "LINIA_JT"],
            "LINIE_JT": [
                "ID_BDI", "DENUM"]
        }

        layer_types = {
            "STALP_JT": "Point",
            "FB pe C LES": "Point",
            "TRONSON_JT": "LineString",
            "BRANS_FIRI_GRPM_JT": "LineString",
            "LINIE_JT": "None"
        }

        created_layers = {}
        
        mistake = False

        for layer_name, columns in layers_to_check.items():
            layers = QgsProject.instance().mapLayersByName(layer_name.strip())
            if not layers:
                continue

            layer = layers[0]
            geom_type = layer_types[layer_name]

            scratch_layer = None
            for feature in layer.getFeatures():
                incomplete_columns = set()
                if layer_name == "STALP_JT":
                    nr_cir_fo_val = feature['NR_CIR_FO']
                    prop_fo_val = feature['PROP_FO']
                    
                    if nr_cir_fo_val not in config.NULL_VALUES and prop_fo_val in config.NULL_VALUES:
                        incomplete_columns.add('PROP_FO (NR_CIR_FO e completat)')
                            
                for column in columns:
                    if column not in [field.name() for field in layer.fields()]:
                        continue
                    value = feature[column]
                    if value in config.NULL_VALUES:
                        incomplete_columns.add(column)
                        
                if incomplete_columns:
                    mistake = True
                    if not scratch_layer:
                        scratch_layer = self.create_scratch_layer(f"{layer_name}_coloane_necompletate", geom_type)
                        created_layers[layer_name] = scratch_layer

                    new_feature = QgsFeature(scratch_layer.fields())
                    new_feature.setAttributes([
                        layer_name,                         
                        ", ".join(incomplete_columns),     
                        feature.id()                            
                    ])
                    if geom_type != "None":
                        geometry = feature.geometry()
                        if geometry and geometry.isGeosValid():
                            new_feature.setGeometry(geometry)
                            
                    scratch_layer.dataProvider().addFeature(new_feature)
            
        if mistake:
            group = QgsProject.instance().layerTreeRoot().addGroup("Coloane necompletate")
            for _, layer in created_layers.items():
                QgsProject.instance().addMapLayer(layer, False)
                group.addLayer(layer)
            
            QMessageBox.warning(None, "Coloane necompletate", "Unele coloane obligatorii nu sunt completate. Verifică layerele rezultate.")
        else:
            QMessageBox.information(None, "Coloane completate", "Toate coloanele obligatorii sunt completate.")

    def verify_circuit(self):
        tronson_layer_name = "TRONSON_JT"

        tronson_layer = QgsProject.instance().mapLayersByName(tronson_layer_name)

        if not tronson_layer:
            return

        tronson_layer = tronson_layer[0]

        dissolve_params = {
            'INPUT': tronson_layer,
            'FIELD': ['LINIA_JT'],
            'OUTPUT': 'memory:',
        }
        dissolved_layer = processing.run("native:dissolve", dissolve_params)['OUTPUT']

        buffer_params = {
            'INPUT': dissolved_layer,
            'DISTANCE': 0.001,
            'SEGMENTS': 5,
            'END_CAP_STYLE': 0,
            'JOIN_STYLE': 0,
            'MITER_LIMIT': 2,
            'DISSOLVE': False,
            'OUTPUT': 'memory:',
        }
        buffered_layer = processing.run("native:buffer", buffer_params)['OUTPUT']

        singlepart_params = {
            'INPUT': buffered_layer,
            'OUTPUT': 'memory:',
        }
        singlepart_layer = processing.run("native:multiparttosingleparts", singlepart_params)['OUTPUT']

        singlepart_layer.setName("Verificare_circuite")

        self.helper.add_layer_to_de_verificat(singlepart_layer)
                
    def apply_categorization(self, layer, field_name):
            unique_values = layer.uniqueValues(layer.fields().lookupField(field_name))
            categories = []
            
            predefined_colors = [
                QColor(255, 0, 0), QColor(0, 255, 0), QColor(0, 0, 255),
                QColor(255, 255, 0), QColor(255, 165, 0), QColor(255, 20, 147),
                QColor(0, 255, 255), QColor(128, 0, 128), QColor(0, 128, 0),
                QColor(0, 0, 128), QColor(75, 0, 130), QColor(255, 105, 180)
            ]
            random.shuffle(predefined_colors)
            
            for i, value in enumerate(unique_values):
                if i >= len(predefined_colors):
                    break
                symbol = QgsSymbol.defaultSymbol(layer.geometryType())
                symbol.setColor(predefined_colors[i])
                symbol.setWidth(1.25)
                categories.append(QgsRendererCategory(value, symbol, str(value)))
            
            renderer = QgsCategorizedSymbolRenderer(field_name, categories)
            layer.setRenderer(renderer)
            layer.triggerRepaint()
        

    def verify_num_columns(self):
        layers_to_check = {
            "STALP_JT": [
                "UZURA_STP", "NR_CIR_FO", "NR_CIR_LTC", "NR_CIR_CATV", "NR_CONS_C2S", "NR_CONS_C4S", "NR_CONS_C2T", "NR_CONS_C4T", "NR_CONS_C2BR", "NR_CONS_C4BR"]
        }

        layer_types = {
            "STALP_JT": "Point",
        }

        created_layers = {}
        mistake = False

        for layer_name, columns in layers_to_check.items():
            layers = QgsProject.instance().mapLayersByName(layer_name.strip())
            if not layers:
                continue

            layer = layers[0]
            geom_type = layer_types[layer_name]

            scratch_layer = None
            for feature in layer.getFeatures():
                incorrect_column = set()
                for column in columns:
                    if column not in [field.name() for field in layer.fields()]:
                        continue
                    value = feature[column]
                    if value not in config.NULL_VALUES:
                        try:
                            value = int(str(value))
                        except ValueError:
                            incorrect_column.add(column)

                if incorrect_column:
                    mistake = True
                    if not scratch_layer:
                        scratch_layer = self.create_scratch_layer(f"{layer_name}_coloane_gresite_nr", geom_type)
                        created_layers[layer_name] = scratch_layer

                    new_feature = QgsFeature(scratch_layer.fields())
                    new_feature.setAttributes([
                        layer_name,                         
                        ", ".join(incorrect_column),     
                        feature.id()                            
                    ])
                    if geom_type != "None":
                        geometry = feature.geometry()
                        if geometry and geometry.isGeosValid():
                            new_feature.setGeometry(geometry)
                            
                    scratch_layer.dataProvider().addFeature(new_feature)
        for _, layer in created_layers.items():
            QgsProject.instance().addMapLayer(layer)
            
        if mistake:
            QMessageBox.information(None, "STALP_JT", "Unele coloane specificate conțin litere în loc de valori strict numerice. Verifică layerul rezultat.")
        else:
            QMessageBox.information(None, "STALP_JT", "Toate coloanele specificate [UZURA_STP, NR_CIR_FO, NR_CIR_LTC, NR_CIR_CATV, NR_CONS_C2S, NR_CONS_C4S, NR_CONS_C2T, NR_CONS_C4T, NR_CONS_C2BR, NR_CONS_C4BR] conțin doar valori numerice.")

            
    def update_true_false_columns(self, st):
        columns_to_check = {
            "NR_CIR_FO": "FIB_OPT",
            "NR_CIR_LTC": "LTC",
            "NR_CIR_CATV": "CATV",
        }

        layer = st

        if not layer.isEditable():
            layer.startEditing()

        field_names = [field.name() for field in layer.fields()]

        for feature in layer.getFeatures():
            for key_field, bool_field in columns_to_check.items():
                if key_field not in field_names or bool_field not in field_names:
                    continue

                key_value = feature[key_field]
                is_completed = key_value not in config.NULL_VALUES

                new_value = "Da" if is_completed else "Nu"

                if feature[bool_field] != new_value:
                    field_index = layer.fields().indexFromName(bool_field)
                    layer.changeAttributeValue(feature.id(), field_index, new_value)

        if not layer.commitChanges():
            QMessageBox.critical(None, "FIB_OPT, LTC, CATV - STALP_JT", "Eroare la actualizarea coloanelor FIB_OPT, LTC, CATV.")
        else:
            send_event(user=self.current_user, action="auto_complete", layer=layer.name())
   
    def update_prop_column(self, st):
        """
        Updates the PROP field in the 'STALP_JT' layer based on the DESC_CTG_MT_JT field.
        If DESC_CTG_MT_JT is in the terti_codes list, PROP is set to 'TERTI';
        if it's in the electrica_codes list, PROP is set to 'ELECTRICA'.
        """
        layer = st

        if not layer.isEditable():
            layer.startEditing()

        terti_codes = [
            'St. lemn tip SU', 'St. lemn tip SG', 'St. metalic rotund',
            'St. octogonal zincat sustinere', 'St. octogonal zincat intindere'
        ]
        electrica_codes = [
            'S 8 - U', 'S 9 - U', 'S 10 - U', 'S 10 - M', 'S 12 - M', 'S 10 - G',
            'S 11 - G', 'S 12 - G', 'S 13 - G', 'S 14 - G', 'SE 1A', 'SE 2', 'SE 3',
            'SE 4', 'SE 5', 'SE 6', 'SE 7', 'SE 8', 'SE 9', 'SE 10', 'SE 11',
            'SC 10001', 'SC 10002', 'SC 10005', 'SC 15004', 'SC 15006', 'SC 15007',
            'SC 15014-10.5', 'SC 15014', 'SI 9', 'SV 10001', 'SV 10002', 'Portal'
        ]

        for feature in layer.getFeatures():
            desc_value = feature['DESC_CTG_MT_JT']
            expected_prop = None

            if desc_value in terti_codes:
                expected_prop = 'TERTI'
            elif desc_value in electrica_codes:
                expected_prop = 'ELECTRICA'
            else:
                # If the description is not in any known list, skip updating.
                continue

            if feature['PROP'] not in [expected_prop, "TERTI + ELECTRICA(comodat)"]:
                feature['PROP'] = expected_prop
                layer.updateFeature(feature)

        if not layer.commitChanges():
            QMessageBox.critical(None, "PROP - STALP_JT", "Eroare la actualizarea coloanei PROP.")
        else:
            send_event(user=self.current_user, action="auto_complete", layer=layer.name())
            
    def update_tip_fund(self, st):
        layer = st

        if not layer.isEditable():
            layer.startEditing()

        turnata_codes = ["St. lemn tip SU", "Portal", "St. lemn tip SG", "SC 10001", "SC 10002", "SC 10005", "SC 15004", "SC 15006", "SC 15007", "SC 15014-10.5", "SC 15014", "St. metalic rotund", "SE 1A", "SV 10001", "SV 10002", "SE 8", "SE 9", "SE 10", "SE 11"]

        for feature in layer.getFeatures():
            desc_ctg_mt_jt = feature["DESC_CTG_MT_JT"]
            
            if desc_ctg_mt_jt:
                if desc_ctg_mt_jt in turnata_codes:
                    layer.changeAttributeValue(feature.id(), layer.fields().indexFromName("TIP_FUND"), "Turnata")
                else:
                    layer.changeAttributeValue(feature.id(), layer.fields().indexFromName("TIP_FUND"), "Burata")

        if not layer.commitChanges():
            QMessageBox.critical(None, "TIP_FUND - STALP_JT", "Eroare la actualizarea coloanei TIP_FUND.")
        else:
            send_event(user=self.current_user, action="auto_complete", layer=layer.name())
            
    def update_nr_circuite(self, st_layer, tr_layer, br_layer):
        """
        Updates STALP_JT.NR_CIR these rules:

        • NR_CIR = # TRONSON_JT that touch the pole
            › ignore branches entirely in this case.

        • If no tronson touch but ≥1 branch does,
            NR_CIR = 1  (constant).

        • In either case, if pole.TIP_CIR contains 'IL' (case-insensitive) add +1.
        """

        # Build spatial indices once
        tr_index = QgsSpatialIndex(tr_layer.getFeatures())
        br_index = QgsSpatialIndex(br_layer.getFeatures())

        # Field indexes on STALP_JT
        idx_nr  = st_layer.fields().indexFromName("NR_CIR")
        idx_tip = st_layer.fields().indexFromName("TIP_CIR")
        if idx_nr == -1 or idx_tip == -1:
            raise ValueError("STALP_JT is missing NR_CIR or TIP_CIR")

        started_edit = False
        if not st_layer.isEditable():
            started_edit = st_layer.startEditing()
            if not started_edit:
                raise RuntimeError("Could not start editing STALP_JT")

        try:
            for pole in st_layer.getFeatures():
                geom_pole = pole.geometry()
                tip_cir   = (pole[idx_tip] or "").upper()

                # ---------- TRONSON: Get unique LINIA_JT ---------- 
                tr_ids = tr_index.intersects(geom_pole.boundingBox())
                tr_unique_names = set(
                    tr_layer.getFeature(fid)[ 'LINIA_JT' ]
                    for fid in tr_ids
                    if tr_layer.getFeature(fid).geometry().intersects(geom_pole)
                )
                tr_cnt = len(tr_unique_names)

                # If at least one TRONSON touches, set NR_CIR to the number of unique LINIA_JT
                if tr_cnt > 0:
                    nr_cir = tr_cnt
                else:
                    # ---------- BRANS: Check if any branch touches ----------
                    br_ids = br_index.intersects(geom_pole.boundingBox())
                    has_branch = any(
                        br_layer.getFeature(fid).geometry().intersects(geom_pole)
                        for fid in br_ids
                    )
                    nr_cir = 1 if has_branch else 0

                # -------- IL bump: Add +1 if TIP_CIR contains 'IL' --------
                if "IL" in tip_cir:
                    nr_cir += 1

                # Set the NR_CIR field for the pole
                pole[idx_nr] = nr_cir
                st_layer.updateFeature(pole)

        finally:
            if started_edit:
                if not st_layer.commitChanges():
                    st_layer.rollBack()
                    QMessageBox.critical(
                        None, "NR_CIR - STALP_JT",
                        "Eroare la actualizarea coloanei NR_CIR."
                    )
                else:
                    send_event(user=self.current_user, action="auto_complete", layer=st_layer.name())
    
    def update_branch_fields(self, br):
        """
        Updates the TIP_BR field in the “BRANS_FIRI_GRPM_JT” layer based on TIP_FIRI_BR,
        validates the result against `links_cond`, and—if mismatches exist—creates a
        scratch layer called “corelare_gresita_conductor” containing only the offending
        features with fields fid, TIP_COND, TIP_BR.
        """
        links_cond = {
            'ACBYCY 10/16': {'monofazat': ['FB1', 'BMPM', 'FDCS']},
            'TYIR 10Al + 16Al': {'monofazat': ['FB1', 'BMPM', 'FDCP', 'FDCS']},
            'AFYI 16+25': {'monofazat': ['FB1', 'BMPM', 'FDCS']},
            'Al 16+25': {'monofazat': ['FB1', 'BMPM', 'FDCS']},
            'TYIR 3x25Al + 16Al': {'trifazat': ['FB3', 'BMPT', 'FDCS']},
            'AFYI 4x16': {'trifazat': ['FB3', 'BMPT', 'FDCS']},
            'ACYABY 4x16': {
                'monofazat': ['BMPM'],
                'trifazat': ['BMPT', 'FDCS']
            },
            'ACBYCY 16/16': {
                'monofazat': ['FB1', 'BMPM', 'FDCS'],
                'trifazat': ['FDCP']
            },
            'AI 16+25': {'monofazat': ['FB1', 'BMPM', 'FDCS']},
            'TYIR 16AI + 25AI': {'monofazat': ['FB1', 'BMPM', 'FDCS']}
        }

        code_to_branch = {
            'FB1': 'monofazat', 'FM1': 'monofazat', 'BMPM': 'monofazat',
            'FB3': 'trifazat',  'FM3': 'trifazat',  'BMPT': 'trifazat'
        }

        fdcs_tip_cond_trifazat = ['TYIR 3X25Al + 16Al', 'AFYI 4X16']
        fdcp_tip_cond_trifazat = ['TYIR 3X25Al + 16Al', 'ACBYCY 16/16']

        layer = br
        if not layer.isEditable():
            layer.startEditing()

        vague = False
        wrong_features = []      # store ids only

        for feature in layer.getFeatures():
            code      = feature['TIP_FIRI_BR']
            tip_cond  = feature['TIP_COND']

            if code in ['FB1', 'FB3']:
                feature['LIM_PROP'] = 'interior'

            # Decide TIP_BR
            if code in code_to_branch:
                branch_value = code_to_branch[code]
            elif code == 'FDCS' and tip_cond.upper() in fdcs_tip_cond_trifazat:
                branch_value = 'trifazat'
            elif code == 'FDCP' and tip_cond.upper() in fdcp_tip_cond_trifazat:
                branch_value = 'trifazat'
            else:
                branch_value = 'monofazat'

            if code == 'FDCS' and tip_cond.upper() == 'ACYABY 4X16':
                vague = True

            feature['TIP_BR'] = branch_value
            layer.updateFeature(feature)

            # Validate against links_cond
            for link, branches_dict in links_cond.items():
                if tip_cond.upper() == link.upper():
                    if branch_value in branches_dict:
                        valid_codes = branches_dict[branch_value]
                        if code not in valid_codes:
                            wrong_features.append(feature.id())

        if not layer.commitChanges():
            QMessageBox.critical(None, 'TIP_BR - BRANS_FIRI_GRPM_JT',
                                'Eroare la actualizarea campului TIP_BR.')
            return
        else:
            send_event(user=self.current_user, action="auto_complete", layer=layer.name())

        if vague:
            QMessageBox.critical(
                None,
                'AVERTIZARE - TIP_BR - BRANS_FIRI_GRPM_JT',
                '⚠️ A fost găsit un caz special pentru FDCS și ACYABY 4X16! '
                'Verifică și completează manual.'
            )

        if wrong_features:
            # wipe any old scratch layer with the same name
            for lyr in QgsProject.instance().mapLayersByName('Corelare_gresita_conductor'):
                QgsProject.instance().removeMapLayer(lyr.id())

            # pick geometry type & CRS identical to source layer
            geom_map = {
                QgsWkbTypes.PointGeometry: 'Point',
                QgsWkbTypes.LineGeometry:  'LineString',
                QgsWkbTypes.PolygonGeometry: 'Polygon'
            }
            geom_str = geom_map.get(layer.geometryType(), 'Unknown')
            scratch = QgsVectorLayer(
                f'{geom_str}?crs={layer.crs().authid()}',
                'Corelare_gresita_conductor',
                'memory'
            )
            pr = scratch.dataProvider()
            pr.addAttributes([
                QgsField('fid', QVariant.Int),
                QgsField('TIP_COND', QVariant.String),
                QgsField('TIP_FIRI_BR', QVariant.String),
                QgsField('TIP_BR', QVariant.String)
            ])
            scratch.updateFields()

            # copy offending features
            for fid in wrong_features:
                orig_feat = layer.getFeature(fid)
                new_feat = QgsFeature(scratch.fields())
                new_feat.setGeometry(orig_feat.geometry())
                new_feat['fid'] = orig_feat.id()
                new_feat['TIP_COND'] = orig_feat['TIP_COND']
                new_feat['TIP_FIRI_BR'] = orig_feat['TIP_FIRI_BR']
                new_feat['TIP_BR'] = orig_feat['TIP_BR']
                pr.addFeature(new_feat)

            scratch.updateExtents()
            self.helper.add_layer_to_de_verificat(scratch)

            self.iface.mapCanvas().refresh()

            QMessageBox.warning(
                None,
                'Mismatches found',
                f'⚠️ Au fost găsite neconcordanțe TIP_COND - TIP_FIRI_BR - TIP_BR\n'
                'Verifică stratul “Corelare_gresita_conductor”.'
            )
            
    def update_uzu_stp_prop_fo(self, st):
        layer = st
        
        if not layer.isEditable():
            layer.startEditing()
            
        field_names = [field.name() for field in layer.fields()]
        
        for feature in layer.getFeatures():
            if "NR_CIR_FO" in field_names and "PROP_FO" in field_names:
                nr_cir_fo = feature["NR_CIR_FO"]
                prop_fo = feature["PROP_FO"]
                if nr_cir_fo not in config.NULL_VALUES and prop_fo in config.NULL_VALUES:
                    layer.changeAttributeValue(feature.id(), layer.fields().indexFromName("PROP_FO"), "SC RCS&RDS S.A")
            
            if "UZURA_STP" in field_names:
                uzura_stp = feature["UZURA_STP"]
                if uzura_stp in config.NULL_VALUES:
                    layer.changeAttributeValue(feature.id(), layer.fields().indexFromName("UZURA_STP"), 5)
                    
        if not layer.commitChanges():
            QMessageBox.critical(None, "UZURA_STP si PROP_FO - STALP_JT", "Eroare la actualizarea coloanelor UZURA_STP si PROP_FO.")
        else:
            send_event(user=self.current_user, action="auto_complete", layer=layer.name())
    
    def verify_streets(self):
        self.process_layers(self.layers)

        def get_layer(layer_name):
            layers = QgsProject.instance().mapLayersByName(layer_name)
            if not layers:
                QgsMessageLog.logMessage(f"Layer '{layer_name}' not found.", 'DesenAssist', Qgis.Critical)
                return None
            return layers[0]

        br_layer = get_layer('BRANS_FIRI_GRPM_JT')
        st_layer = get_layer('STALP_JT')
        fb_layer = get_layer('FB pe C LES')

        if not (br_layer and st_layer and fb_layer):
            return

        for layer in [br_layer, st_layer, fb_layer]:
            layer.startEditing()
            for feature in layer.getFeatures():
                if feature.fields().lookupField("STR") != -1:
                    street = feature["STR"]
                    if street:
                        feature["STR"] = street.strip()
                        layer.updateFeature(feature)
                        
            if not layer.commitChanges():
                QMessageBox.critical(None, "Verificare străzi", f"Eroare la actualizarea străzilor în {layer.name()}.")
                return
            else:
                send_event(user=self.current_user, action="auto_complete", layer=layer.name())
                
                
        dialog = GenerateExcelDialog(self.base_dir)
        dialog.exec_()
        
    def trigger_calc_length(self):
        if self.action_length.text() != "Lungime TRONSON_JT: apasă pentru calcul":
            return
        
        layers = QgsProject.instance().mapLayersByName("TRONSON_JT")
        if layers:
            self.layer = layers[0]
            self.connectLayerSignals(self.layer)
            self.recalc_length()
            
        QMessageBox.information(None, "Lungime TRONSON_JT", "Lungimea totală a fost calculată și va fi actualizată automat în timp real.")
        QgsProject.instance().layersAdded.connect(self.onLayersAdded)
        QgsProject.instance().readProject.connect(self.onProjectRead)


    def connectLayerSignals(self, layer):
        layer.featureAdded.connect(self.recalc_length)
        layer.featuresDeleted.connect(self.recalc_length)
        layer.geometryChanged.connect(self.recalc_length)
        layer.committedFeaturesAdded.connect(self.recalc_length)
        layer.committedFeaturesRemoved.connect(self.recalc_length)
        layer.committedGeometriesChanges.connect(self.recalc_length)
        layer.afterCommitChanges.connect(self.recalc_length)

    def onLayersAdded(self, layers):
        for layer in layers:
            if layer.name() == "TRONSON_JT":
                self.layer = layer
                self.connectLayerSignals(layer)
                self.recalc_length()

    def onProjectRead(self):
        layers = QgsProject.instance().mapLayersByName("TRONSON_JT")
        if layers:
            self.layer = layers[0]
            self.connectLayerSignals(self.layer)
            self.recalc_length()

    def recalc_length(self):
        """Recalculate total length for TRONSON_JT, ignoring overlaps."""
        if not self.layer:
            return

        total_union = None
        for feat in self.layer.getFeatures():
            geom = feat.geometry()
            if not geom or geom.isEmpty():
                continue
            
            if total_union is None:
                total_union = geom
            else:
                total_union = total_union.combine(geom)

        total_length_km = 0.0
        if total_union:
            total_length_km = total_union.length() / 1000.0

        if self.action_length:
            self.action_length.setText(
                self.tr(u"Lungime TRONSON_JT: {:.2f} km".format(total_length_km))
            )
        

    def verify_vector(self):
        '''
        Verifies the geometry and fields
        Adds temporary layers with the mistakes: point, line
        STALP_JT - point layer
        BRANS_FIRI_GRPM_JT - line layer
        TRONSON_JT - line layer
        
        fields: NUME_LAYER, FID, TIP_EROARE, DETALII
        
        1. STALP_JT has to be snapped to TRONSON_JT or BRANS_FIRI_GRPM_JT; no feature from any layer left in the air
            
        2. STALP_JT ce se intersecteaza cu BRANS_FIRI_GRPM_JT = "BR" trebuie sa fie inclus la TIP_CIR, else error (+ vice versa - daca exista BR dar nu se intersecteaza cu BRANS_FIRI_GRPM_JT - eroare)
        
        3. STALP_JT ce se se intersecteaza cu TRONSON_JT + DENUM fara litere = "JT" trebuie sa fie inclus la Tip Circuit, else error (+ vice versa - daca exista JT dar nu se intersecteaza cu TRONSON_JT - eroare)
                
        4. STALP_JT (snapped to BRANS_FIRI_GRPM_JT) terminal = orice este cu litere la DENUM si la TIP_LEG_JT == t sa dea eroare
        
        5. La capat de TRONSON_JT (daca tronsonul nu e legat de altul) - ultimele STALP_JT trebuie sa aiba TIP_LEG_JT "t" sau "t/d"
        
        '''
        try:
            verifier = VectorVerifier(self.iface)
            verifier.verify()        # run the whole check
            QMessageBox.information(
                None, "Verificare vectorială",
                "Verificarea vectorială a fost finalizată cu succes!"
            )
            
        except Exception as e:
            # surfaces any missing fields, layer-name typos, etc.
            self.iface.messageBar().pushCritical("Verificare vectorială", str(e))

        pass